# opt_depot v3.0 -*- Perl -*-
#
# This script will go through the $depot directory and find files in
# specific subdirectories of various packages and make links in the
# corresponding $dest direcories (i.e. it will take the "lib", "man",
# "bin", "info", "include", etc. directories under any subdirectory
# of $depot and link all the files together under $dest/lib, $dest/man,
# etc.).
#
#************************************************************************
#
# Copyright (C) 1993-2003  The University of Texas at Austin.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
#    02111-1307, USA
#
#    Written by: Computer Science Division, Applied Research Laboratories,
#    University of Texas at Austin  opt-depot@arlut.utexas.edu
#
#***********************************************************************
# Written by Jeremy Thibeaux, Jonathan Abbey, Amy Shook
# October 8, 1993 - June 1, 1997
#
# v2.0
# Added modifications to allow opt_depot to create subdirecrories under
# /bin/lib/man/info/include to better accommodate package conflicts
# and added ability to access directory info from a configuration file
# Erik Grostic 15 May 1997
#
# v2.01
# Fixed a bug in procargs that had to do with the regex matching for
# re-defining the destination directory by using command line parameters.
# A -b option must now be given with the destination (or base) directory
# Erik Grostic 10 July 1997
#
# v3.0
# Reworked the recursive unification implementation to not get confused
# due to an under-specified regexp.  Made the per-package exclude files
# properly affect man page linking.  Reworked tons to use Opt_depot::Common,
# and modern Perl module function support.  Script is now position
# independent.  No more attempts at Perl 4 compatibility for us, no sir.
# Jonathan Abbey 25 July 2003
#
#
# Release: $Name:  $
# Version: $Revision: 1.43 $
# Last Mod Date: $Date: 2003/10/06 22:07:31 $
#
#####################################################################

use English;
use FindBin qw($RealBin);

use lib "$RealBin/../modules";
use Opt_depot::Common;

$version = "3.0";

## defaults #########################################################

$debug = 1;
$force_verbose = 1;

# configuration file containing $dest, $depot and $logdir vars

$local_config_file = resolve($RealBin, "../etc/opt.config");

# this file is created by opt_depot when it makes a directory. only
# those directories containing this hidden file may be removed or
# collapsed by opt_clean

$opt_file = ".made_by_opt_depot";

#####################################################################
#
# Internal Variables
#
# %exclude - Associative Array used to keep track of individual files
#           to be excluded
#
# %priority - Contains files and package names
#             that have priority lines associated with them.
#
#             All files and packages listed in the $dest/.priority
#             file are assigned a priority number, with the earliest
#             entries in the file given the highest priority value
#
#             If a file is involved with a conflict but there are no
#             priority lines specified for that file, opt_depot will
#             check to see if any containing directory to which the
#             files belong have priority, and will maintain the link
#             whose package priority has the higher priority.
#
#####################################################################


#####################################################################
#
#                                                         needs_unify
#
# input: relative directory component to test ('include', etc.)
#
# uses: global @unify_list array
#
# output: returns 1 if the directory needs to be unified
#
#####################################################################
sub needs_unify {
  my ($param) = @_;

  my ($temp, $match, $p);

  # if we were given the -R flag, we always want to unify, whatever path
  # we're looking at

  if (exists $switches{'R'}) {
    return 1;
  }

  # failing -R, if we're not given the -r flag, we're not recursing,
  # so return 0

  if (!exists $switches{'r'}) {
    return 0;
  }

  # We are going to be sure that we suffix our search term and list of
  # to-be-unified subdirectories with trailing slashes if they lack
  # them.  The purpose of this is to prevent matching a directory
  # substring, as in lib matching libexec.

  $match = "$param";

  if ($match !~ /\/$/) {
    $match = "$param/";
  }

  foreach $p (@unify_list) {
    $temp = $p;

    if ($temp !~ /\/$/) {
      $temp = "$p/";
    }

    if ($match =~ /^$temp/) {
      return 1;
    }
  }

  return 0;
}

#########################################################################
#
#                                                             read_exfile
#
# input: name of an exclude file to process
#
# uses: %exclude
#
# output: writes to the %exclude associative array
#
# see the definition of %exclude at the top of this file
#
#########################################################################
sub read_exfile {
  my($exfile) = @_;

  if (-e $exfile) {
    open(EXFILE, $exfile) || die "Could not open $exfile";

    while (<EXFILE>){
      s/\s+$//;			# cut off trailing whitespace

      if (/^\s*#/) {
	next; # comment line - skip
      }

      if (/^\s*$/) {
	next; # blank line - skip
      }

      if (/^\s*\'/ || /^\s*\"/) {
	$_ = parsequoted($_, 0); # leave in escapes

	# if we have an unescaped :, treat that as a label separator,
	# and skip this entry.. we (opt_depot) don't care about
	# exclusions from a particular site volume.. that's for
	# opt_link.

	if (!/(?:\\.|[^:])*$/){	
	  next;
	}

	# now take out escapes

	s/\\(.)/$1/g;

	# now see if we're excluding a qualified or nonqualified file name

	if (/^(\/.+)$/) {
	  # leading slash -- take this as an absolute path name
	  # $1 is the complete absolute path/filename

	  $exclude{removelastslash($1)}=1;
	} else {
	  # take this as a depot directory relative path
	  # $1 is the complete relative path and filename

	  $exclude{removelastslash("$depot/$1")}=1;
	}
      } else {

	# no quotations, so we'll use the older, simpler parse logic

	if (/:/){	
	  next; # a labelled exclusion. Forget about it.
	}

	if (/^\s*(\/\S+)/) {
	  # leading slash -- take this as an absolute path name
	  # $1 is the complete absolute path/filename

	  $exclude{removelastslash($1)}=1;
	} elsif (/^\s*(\S+)/) {
	  # take this as a depot directory relative path
	  # $1 is the complete relative path and filename
	
	  $exclude{removelastslash("$depot/$1")}=1;
	} else {
	  logprint("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	}
      }
    }

    close(EXFILE);
  }
}

#########################################################################
#
#                                                            read_pack_ex
# input: $exfile - name of the per/package exclusion file
#
# uses: $depot
#       %exclude
#
# output: if a package is currently linked in $depot, and that package
#         has its own .exclude file, then the exclusions listed in that
#         file are added to the main exclusion hash.
#
#########################################################################
sub read_pack_ex {
  my(@allfiles,@contents);

  opendir (IN, $depot) || die "Could not open $depot";
  @contents = readdir(IN);
  closedir (IN);

  @allfiles = grep (-d "$depot/$_" && !/^\.\.?$/, @contents);

  foreach $file (@allfiles) {
    if (-e "$depot/$file/.exclude") {
      open(EXFILE, "$depot/$file/.exclude") || die "Could not open $depot/$file/.exclude";

      while (<EXFILE>){
	s/\s+$//;		# cut off trailing whitespace

	if (/^\s*#/) {
	  next;	  # comment line - skip
	}

	if (/^\s*$/) {
	  next; # blank line - skip
	}

	if (/^\s*\"/ || /^\s*\'/) {
	  $_ = parsequoted($_, 1);

	  if (/^(\/.+)$/) {
	    # leading slash -- take this as an absolute path name
	    # $1 is the complete absolute path/filename

	    $exclude{"$1"}=1;
	  } elsif (/^([^\/]+\/.+)$/) {
	    # No leading slash but there are embedded slashes..
	    # take this as a depot directory relative path
	    # $1 is the complete relative path and filename

	    $exclude{"$depot/$1"}=1;
	  } elsif (/^([^\/]+)$/) {
	    # No leading slash and no embedded slashes take this as a
	    # package name and version num if any is included.  Don't
	    # worry about those in per-package exclusions, opt_link
	    # looks at those at depot link time

	    next;
	  } else {
	    logprint("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	  }
	} else {
	  if (/^\s*(\/\S+)/) {
	    # leading slash -- take this as an absolute path name
	    # $1 is the complete absolute path/filename
	    $exclude{"$1"}=1;
	  } elsif (/^\s*([^\/]+\/\S*)/) {
	    # No leading slash but there are embedded slashes..
	    # take this as a depot directory relative path
	    # $1 is the complete relative path and filename

	    $exclude{"$depot/$1"}=1;
	  } elsif (/^\s*([^\/]+)$/) {
	    # No leading slash and no embedded slashes take this as a
	    # package name.  We don't care about packages in
	    # per-package exclusion files.. those are for opt_link to
	    # handle.

	    # Note that this regexp is a bit underspecified, since it
	    # will encompass whitespace, but we don't care since we're
	    # just ignoring it anyway

	    next;
	  } else {
	    logprint ("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	  }
	}
      }

      close(EXFILE);
    }
  }
}

#########################################################################
#
#                                                            read_prifile
#
# input: name of a priority file to process
#
# uses: %priority
#
# output: writes to associative arrays %priority
#
# see the definition of %priority at the top of this file
#
#########################################################################
sub read_prifile {
  my($prifile) = @_;

  my(@parray, $i, $item);

  if (!-e $prifile) {
    return;
  }

  open (PRIFILE, $prifile) || die "Could not open $prifile";

  while (<PRIFILE>) {
    s/\s+$//;			# cut off trailing whitespace

    if (/^\s*#/) {
      next;			# skip comment line
    }

    if (/^\s*$/) {
      next;			# skip blank line
    }

    if (/^\s*\"/ || /^\s*\'/) {
      $_ = parsequoted($_, 1); # take out escapes

      if (/^(\/.*)/) {
	# leading slash - absolute filename
	# handle priority for individual file
	# this clause handles absolute pathnames
	
	unshift(@parray, $1);
      } else {
	# this clause handles depot relative pathnames
	unshift(@parray, "$depot/$1");
      }
    } else {
      if (/^\s*(\/\S+)/) {
	# leading slash - absolute filename
	# handle priority for individual file
	# this clause handles absolute pathnames
	unshift(@parray, $1);
      } elsif (/^\s*(\S*)/) {
	# this clause handles depot relative pathnames
	unshift(@parray, "$depot/$1");
      }
    }
  }

  close(PRIFILE);

  # assign ascending priorities, as we go from the last entry from the
  # priority file towards the first.. we used unshift above so that the
  # last entry in the file is first in our list

  $i = 1;

  foreach $item (@parray) {
    $priority{$item} = $i++;
  }
}

#########################################################################
#
#                                                                 makedir
#
# input: name of a directory to create
#
# makedir() creates a directory and sets permissions on it to 755,
# honoring the 'n' switch which inhibits actual file operations for the
# sake of showing what would be done.
#
#########################################################################
sub makedir {
  my($dir) = @_;

  if (!($switches{'n'})) {
    mkdir($dir, 0755) || die "Could not make $dir";
    print (LOG "  Made:   directory $dir\n") if (!($switches{'q'}));
  }

  print ("  Make:   directory $dir\n") if ($switches{'v'});
}

#########################################################################
#
#                                                               smartlink
#
# Check a proposed new link for conflicts, exclusion, and priority.. if
# the new link should be made, smartlink will call fablink to get the job
# done.
#
# input: $package - name of package containing $target
#        $target - an absolute filename to possibly generate a link to
#        $link - the absolute filename of the link to be generated
#
# output: potentially generates a symbolic link from $link to $target
#         returns 1 if a new link was made, 0 otherwise
#
# smartlink() may not generate a link if an existing link has a higher
# priority, or if $target or the package that $target is under has been
# excluded due to a reference in the .exclude file.
#
# in general, smartlink() will not overwrite an existing link unless the
# .priority or .exclude file specifically gives the new link priority
# over the existing link.
#
#########################################################################
sub smartlink {
  my ($package, $target, $link) = @_;

  my ($oldtarget, $op, $np, $opp, $npp);

  # if we are supposed to exclude this file, skip linking it

  if (pathcheck($target, *exclude)) {
    logprint(" *** excluding $target\n", 0);
    return 0;
  }

  # if there's nothing in the location of our link target, make the
  # link and get out

  if (!-e $link && !-l $link) {
    logprint("Smartlink: No $link found, proceeding\n", -1);
    return fablink($link, $target);
  }

  # if there's something other than a symlink (a physical file,
  # directory, socket, etc.) report and get out

  if (!-l $link) {
    logprint("  ERROR:  $link already exists and is not a link\n", 0);
    logprint("          Did not make link to link $target\n", 0);

    push(@conflicts,"  $target (conflict: physical file/directory)\n");

    return 0;
  }

  # okay, we've got a symlink at $link.  Let's find where it's pointing
  # to.

  logprint("Smartlink found already exists link $link->" . readlink("$link") . "\n", -1);

  $oldtarget = resolve(extractdir($link), readlink($link));

  logprint("Smartlink: oldtarget is $oldtarget\n", -1);

  # no change?  don't do anything.

  if ("$oldtarget" eq "$target") {
    return 0;
  }

  # if the existing link points out of $depot, we're done

  if ("$oldtarget" !~ /^$depot\//) {
    return 0;
  }

  # now, we've got a new link into the depot tree to make, maybe..
  # let's check out our priority and exclusions for the old target
  # vs. the new

  # if the old link is excluded, for sure retarget the link

  if (pathcheck($oldtarget, *exclude)) {
    return fablink($link, $target);
  }

  # --
  #
  # okay, from here on out, we're just interested in the relative
  # priority of the old and new targets.  We'll first check for
  # an explicit record of the given file.. we always give explicitly
  # listed files priority over directory paths.
  #
  # --

  # check explicit priorities for the specific old and new targets
  # first..

  $op = $priority{$oldtarget};
  $np = $priority{$target};

  if ($op > $np) {
    return 0;
  } elsif ($np > $op) {
    return fablink($link, $target);
  }

  # now check for the old and new path priorities

  $opp = pathcheck($oldtarget, *priority);
  $npp = pathcheck($target, *priority);

  if ($npp > $opp) {
    return fablink($link, $target);
  }

  # $opp is >= $npp, then.  If $opp is 0, $npp must be as well, and we
  # have a conflict with no priorities to help us resolve it.  Make a
  # note.

  if (!$opp) {
    push(@conflicts,"  $target (conflict: $oldtarget)\n");
  }

  return 0;
}

#########################################################################
#
#                                                                 fablink
#
# Actually create a symlink in the filesystem, removing an old one
# if necessary
#
#########################################################################
sub fablink {
  my ($newlink, $target) = @_;

  # if we're in test mode, just show the action to take

  if (-l $newlink) {
    if ($switches{'n'}) {
      print ("  unlink:   $newlink ->\n");
      print ("            $target\n");
    } else {
      if (!unlink($newlink)) {
	logprint("  ERROR:  Could not remove $newlink", 1);
	return 0;
      }
    }
  }

  if ($switches{'n'}) {
    print ("  link:   $newlink ->\n");
    print ("          $target\n");

    return 1;
  }

  if (!symlink($target,$newlink)) {
    logprint("  ERROR: Could not link $newlink\n", 0);
    push (@conflicts, "  $target (link failed)\n");

    return 0;
  }

  logprint("  link:   $newlink ->\n", 0);
  logprint("          $target\n", 0);

  return 1;
}

#########################################################################
#
#                                                                 manlink
#
# input: $package - name of package to link man pages for
#
# output: potentially links man pages into $dest/man
#         if a link is made, global $mademan is set to 1
#
#########################################################################
sub manlink {
  my ($package) = @_;

  my ($file, @files, $mfile, @mfiles, $newsuf);

  # check under $package/man and link appropriate files under man1, man2, etc

  if (!-e "$depot/$package/man") {
    return;
  }

  # extract all files and directories

  opendir (MAN, "$depot/$package/man") || print "Could not open $depot/$package/man.";
  @files=grep (!/^\.\.?$/, readdir(MAN));
  closedir(MAN);

  for $file (@files) {

    if (pathcheck("$depot/$package/man/$file", *exclude)) {
      # do nothing.. don't link these manpages
	
      logprint("  Excluding man directory $depot/$package/man/$file/\n", 0);

      next;
    }

    # if file is a man directory then link all man files under it.
    # there really shouldn't be anything in the package's man
    # directory except man subdirectories (i.e., not cat directories),
    # but there might be readme's or something.  we'll ignore those.
	
    if (-d "$depot/$package/man/$file" && $file =~ /^man([0-9a-z]+)$/) {

      # we've got a man directory.  $1 is the man dir suffix

      $suf=$1;

      # make sure that the appropriate man and cat directories
      # exist in $dest/man..

      if (!(-e "$dest/man/man$suf")) {
	makedir("$dest/man/man$suf");
      }

      if (!(-e "$dest/man/cat$suf")) {
	makedir("$dest/man/cat$suf");
      }

      if (-d "$depot/$package/man/$file") {
			
	opendir (MDIR, "$depot/$package/man/$file") || print "Could not open $depot/$package/man/$file";
	@mfiles=grep (!/^\.\.?$/, readdir(MDIR));
	closedir (MDIR);
			
	# link all man pages in this man directory into the
	# appropriate $dest directory
			
	for $mfile (@mfiles) {

	  if ($mfile =~ /\.([^\.]+)$/) {
				
	    $newsuf = $1;
				
	    # if the man page's filename doesn't end in the right
	    # suffix, warn the user and link it where it should
	    # go.
				
	    if ($newsuf ne $suf) {

	      # if the man page ends in a suffix different than
	      # that of the directory it is contained in,
	      # we'll want to correct this by placing it in
	      # the appropriate place.  If the directory
	      # does not exist, we'll want to create it.

	      if (!-e "$dest/man/man$newsuf") {
		makedir("$dest/man/man$newsuf");
	      }

	      if (!-e "$dest/man/cat$newsuf") {
		makedir("$dest/man/cat$newsuf");
	      }
	    }
				
	    if (smartlink($package, "$depot/$package/man/$file/$mfile", "$dest/man/man$newsuf/$mfile")) {
	      if ($newsuf ne $suf) {
		logprint("WARNING: suffix does not match directory for $depot/$package/man/$file/$mfile\n", 0);
		logprint("         Placed in $dest/man/man$newsuf\n", 0);
	      }
		
	      $mademan=1;
	    }
	  } else {
				
	    # the filename wasn't valid for a manpage

	    logprint("WARNING: file $depot/$package/man/$file/$mfile is not properly named for a man page..\n", 0);
	    logprint("         Not linking\n", 0);
	  }
	}
      }
    } else {
	
      # $file isn't a directory.. perhaps this means that this
      # package's man directory directly contains man pages rather
      # than man1..mann subdirectories.  check to see if we have a man
      # file with a recognizable extension, and link it into the
      # appropriate man subdirectory if so.
	
      if (-f "$depot/$package/man/$file" && $file =~ /\.([^\.]+)$/) {

	# file is a man page, link it to the appropriate man
	# directory.
			
	# note that this means that the man directory in this
	# package isn't structured properly, but we can deal with
	# it since we have the suffix to guide us.
			
	if (!(-e "$dest/man/man$1")) {
	  makedir("$dest/man/man$1");
	}

	if (!(-e "$dest/man/cat$1")) {
	  makedir("$dest/man/cat$1");
	}

	smartlink($package, "$depot/$package/man/$file", "$dest/man/man$1/$file");
	$mademan=1;
      }
    }
  }
}

#########################################################################
#
#                                                                prepdirs
#
# input: none
#
# uses:  globals @subdirs, $dest
#
# output: makes sure that all the desired directories exist in $dest
#         if prepdirs can't, it dies
#
#########################################################################
sub prepdirs {

  my ($subdir);

  for $subdir (@subdirs) {
    if (!-e "$dest/$subdir") {
      makedir("$dest/$subdir");
    } elsif (!-d "$dest/$subdir"){
      die "ERROR: $dest/$subdir is not a directory";
    }
  }

  if (!-e "$dest/man") {
    makedir("$dest/man");
  } elsif (!-d "$dest/man") {
    die "ERROR: $dest/man is not a directory";
  }
}

#########################################################################
#
#                                                          synthesize_dir
# input: a pathname
#
# uses: opt_file global variable name
#
# output: makes sure the specified directory exists. If it doesn't
#         then synthesize_dir makes it (along with any necessary
#         super-directories), and places a .made_by_opt_depot tag in
#         it.
#
#########################################################################
sub synthesize_dir {
  my ($file) = @_;

  my ($temp, @components);

  @components = split(/\//, $file);

  foreach $comp (@components) {
    $temp .= "$comp";

    if (! -d $temp && ($temp ne "")) {
      if (!$switches{'n'}) {
	mkdir($temp, 0755) || print "Could not make dir $temp\n";
	open (NEW, ">$temp/$opt_file") || die "Waaaah!!!";
	print NEW "This file is used by opt_depot to keep track of created directories.\n";
	print NEW "Please don't delete me.  Thanks.\n";
	close NEW;
      }

      logprint("MKDIR $temp\n", 0);
    }	

    $temp .= "/";  # add trailing /
  }
}

#########################################################################
#
#                                                             depth_first
# input: * Two packages for comparison
#        * The current directory under $dest (ie lib, bin, info, include)
#
# uses: merge_list associative array, global @all_dirs
#
# output: depth_first takes two packages that have directory conflicts and
#         determines whether or not to merge these directories by utilizing
#         a depth_first recursive search and comparing the individual files
#         of the directory and sub-directories.
#
#
#########################################################################
sub depth_first {

  my ($new_pack_root, $old_pack_root, $opt_directory) = @_;

  my ($current_dir, @dirs, @files, @contents,$temp);
  my ($pack_prefix, $merge_target);
  my ($new_file, $old_file);

  # The first time we enter this function, we'll prep the @all_dirs
  # array with the name of the $new_pack_root.  This should be an
  # unqualified package name, as the assumption is that the bulk of
  # the opt_depot script is run after we do a chdir() into the $depot
  # directory.

  if ($#all_dirs < 0) {
    $all_dirs[0] = $new_pack_root;
  }

  if ($debug) {
    print "\nentering depth_first\n--------------------\n\@all_dirs = ";
    printwrap(join(', ', @all_dirs));
    print "\n\$new_pack_root = $new_pack_root\n";
    print "\$old_pack_root = $old_pack_root\n";
    print "\$opt_directory = $opt_directory\n";
  }

  # Now we continue with our depth-first traversal.  What we want to
  # do is to visit all subdirectories of $depot/$new_pack_root in
  # depth-first order.  When the recursive traversal phase is done, we
  # will see if any files exist in the subdirectory ($current_dir)
  # that we are visiting in both the new package we are linking in and
  # the old package that was already linked.  If so, and if the
  # priority supports any files from the new package to be linked,
  # we'll add an entry to %merge_list, indicating that that directory
  # needs to be created under $dest/$opt_directory

  $current_dir = pop (@all_dirs);

  opendir(DIR, $current_dir);
  @contents = readdir(DIR);
  closedir(DIR);

  @dirs = grep (!/^\.\.?$/ && -d "$current_dir/$_", @contents);
  @files = grep (!-d "$current_dir/$_", @contents);

  foreach $dir (@dirs) {
    push (@all_dirs, "$current_dir/$dir");
  }

  if ($#all_dirs >= 0) {
    depth_first($new_pack_root, $old_pack_root, $opt_directory);
  }

  # now that we've finished recursing down, let's take a look at
  # what's in this directory and see if we need to add some merge
  # stuff here

  foreach $file (@files) {
    $new_file = "$current_dir/$file";

    # copy $new_file string to $old_file, replacing the $new_pack_root
    # prefix with the $old_pack_root prefix, so that we can compare the
    # existence of files in the common relative location of the new
    # and old packages we're looking at merging

    $old_file = $new_file;
    $temp = $new_pack_root;
    $temp =~ s/(\W)/\\$1/g;	# backslash escape any special chars
    $old_file =~ s/^$temp/$old_pack_root/;

    logprint("\nHey! \$new_file is $new_file, \$old_file is $old_file\n", -1);

    $pack_prefix = first_path_element($new_pack_root);

    if ($current_dir =~ /^$pack_prefix\/$opt_directory\/(.*)$/) {
      $merge_target = "$dest/$opt_directory/$1";
      logprint("\nHey!  \$merge_target is $merge_target\n", -1);
    } else {
      logprint("Error, couldn't break the '$pack_prefix/$opt_directory' prefix from '$current_dir'\n", 1);
      next;
    }

    if (!defined $merge_list{$merge_target}) {
      if ((-e $new_file && !-e $old_file) ||
	  (pathcheck($new_file, *priority) > pathcheck($old_file, *priority))) {
	if (pathcheck($new_file, *exclude)) {
	  logprint("\n  *** EXCLUDING DIRECTORY: $new_file\n\n", 0);
	} else {
	  $merge_list{$merge_target} = 1;
	}
      }
    }
  }
}

#########################################################################
#
#                                                                 link_me
#
# input: $sub_dir - name of the current directory where link_me is being
#                       called
#        $opt_directory - name of the first directory under /$dest that we are
#        currently under (ie lib, info, include, bin...)
#        @pack_list - list of packages that are ready to be considered for
#                     linking under $dest directory
#
# output: potentially creates links to files under $dest directory
#
# link_me carries out the recursive linking of files into the bin lib info
# and include directories under $dest
#
#########################################################################

sub link_me {
  my ($subdir, $opt_directory, @pack_list) = @_;

  my (%pack_hash, $common_dir, @temp_list);
  my ($i, $old_target, $old_pack, $new_pack, $temp, $element, $conflict);
  my (@recurse_list);

  logprint("LINKING:  $subdir\n", 0);

  foreach $package (@pack_list) {
    if (pathcheck("$depot/$package/$subdir", *exclude)) {
      logprint("\n  *** EXCLUDING DIRECTORY: $depot/$package/$subdir\n\n", 0);

      next;
    }

    if (!-d "$depot/$package/$subdir") {
      next;
    }

    if (opendir(SUBDIR, "$depot/$package/$subdir")) {
      @files= grep (!/^\.\.?$/, readdir(SUBDIR));
      closedir(SUBDIR);
    } else {
      logprint("Could not open $depot/$package/$subdir\n", 1);
    }

    foreach $file (@files) {
      undef @temp_list;
      $common_dir = "$subdir/$file";

      if (-d "$depot/$package/$common_dir") {
	# we're looking at a subdirectory.. unify?

	$new_pack = "$package/$common_dir";

	if (-l "$dest/$common_dir" ) {
	  # link already exists in $dest

	  logprint("Found already exists link $dest/$common_dir->" . readlink("$dest/$common_dir") . "\n", -1);

	  $old_target = resolve(extractdir("$dest/$common_dir"),
				readlink("$dest/$common_dir"));

	  if ($old_target !~ /^$depot\/(.*)/) {
	    # old link points outside of the depot tree, leave it alone
	    next;
	  }

	  $old_pack = $1;

	  # $old_pack now has a depot directory-relative path from
	  # the old link

	  if ($new_pack eq $old_pack) {
	    # nothing to do, the link points where we think it should
	    # here
	    next;
	  }

	  undef %merge_list;

	  # check and see if a merge is actually required

	  if (needs_unify($subdir)) {
	    depth_first($new_pack, $old_pack, $opt_directory);

	    # if we've decided to merge things, let's remove the
	    # old symlink and create as many subdirectories as
	    # necessary.  We'll create records in %pack_hash of
	    # directories we'll need to continue to recurse down
	    # into in order to possibly do deeper directory
	    # unification

	    if (defined %merge_list) {
	      @temp_list[0] = $old_pack;
	      @temp_list[1] = $new_pack;
	      $pack_hash{$common_dir} = [ @temp_list ];
	      unlink("$dest/$common_dir"); # remove old symlink

	      foreach $dir (keys %merge_list) {
		synthesize_dir($dir);
	      }

	      next; # we've made directories, we'll do the linking through recursion
	    }
	  }
	} elsif (-d "$dest/$common_dir") {
	  # there is already a subdirectory built for us.
	  # Cool.  We'll still need to record the subdirectories
	  # for further recursion.

	  if (! defined $pack_hash{$common_dir}) {
	    @temp_list[0] = $new_pack;
	    $pack_hash{$common_dir} = [ @temp_list ];
	  } else {
	    @temp_list = @{ $pack_hash{$common_dir}};
	    push (@temp_list, $new_pack);
	    $pack_hash{$common_dir} = [ @temp_list ];
	  }

	  next; # ditto -- wait to recurse to link
	}
      } # end if (-d "$depot/$package/$subdir/$file")

      # no subdirectory unification to worry about, just look to see
      # if the new file or directory ($depot/$package/$subdir/$file
      # can be a directory) has priority or exclusion rights over
      # the current "$dest/$subdir/$file", if any.  if so, we'll
      # unlink the old and link the new.

      logprint("Calling smartlink on ($package, $depot/$package/$common_dir, $dest/$common_dir)\n", -1);

      smartlink($package, "$depot/$package/$common_dir", "$dest/$common_dir");
    } # foreach $file
  } # foreach $package

  #
  # make recursive call to link_me if necessary..
  #

  if (!defined %pack_hash || (!defined $switches{'r'} && !defined $switches{'R'})) {
    return;
  }

  # we've got one or more directory conflicts. let's call link_me
  # again to resolve each

  foreach $conflict (keys %pack_hash) {
    #print"\tSubdirectory: $conflict\n";
    @recurse_list = @{ $pack_hash{$conflict} };

    foreach $element (@recurse_list) {
      $temp = $conflict;
      $temp =~ s/(\W)/\\$1/g;	# quote meta-chars
      $element =~ s/\/$temp//; # removes the common directory
      # name from the package
      #print"\tElement: $element\n";
    }

    if (needs_unify($conflict)) {
      link_me($conflict,$opt_directory, @recurse_list);
    }
  }	
}

################################################################################
#                                                                              #
#                                     MAIN                                     #
#                                                                              #
################################################################################

$usage_string =<<'ENDUSAGE';
Usage:  opt_depot [-svnqmrR] [-f\"config file\"] [-d\"depot dir\"]
                  [-l\"log dir\"] [-b\"software base dir\"]
ENDUSAGE

read_prefs($usage_string, $local_config_file, "svnqmrR", @ARGV);
init_log("opt_depot", $version, $debug);

if ($force_verbose) {
  $switches{'v'} = '-v';
}

if (!check_lock("opt_depot")) {
  logprint("Can't create lockfile, aborting\n", 1);
  exit(1);
}

read_exfile("$dest/.exclude");	# initialize exclude hash from primary file
read_pack_ex();			# add per-package exclusions to exclude hash
read_prifile("$dest/.priority");
prepdirs();			# get our dirs set up

##
## MAIN PROCESS
##

# get a list of packages installed in $depot.. we don't
# want to deal with invisible files or the . and .. dirs

chdir $depot || die "Could not cd to $depot";

opendir (DEPOT, $depot) || die "Could not open $depot";
@packages=grep(-d && !/^\.\.?$/, readdir(DEPOT));
closedir(DEPOT);

foreach $subdir (@subdirs) {
  # This is the name of the primary directory
  # we're working in (ie lib, bin, info, etc).

  $opt_directory = $subdir;

  if ($subdir ne "man") {
    link_me($subdir,$opt_directory, @packages);
  } else {
    logprint("LINKING:  man\n",0);

    foreach $package (@packages) {
      if (!defined $exclude{"$depot/$package"}) {
	manlink($package);
      }
    }
  }
}

#
# list uncreated links
#

if ($conflicts[0]) {
  logprint("\nUNMADE OR UNDONE LINKS:\n", 0);
  logprint("@conflicts", 0);
}

#
# rebuild catman database if we touched the manpages
#

if ($mademan && $switches{'m'} && -x "/usr/bin/catman") {
  logprint("  Rebuilding man page indices\n", 0);
  system("/usr/bin/catman -w -M $dest/man");
  logprint("  Man page indices rebuilt \n", 0);
}

clear_lock();
close_log();
