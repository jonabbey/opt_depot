#
# opt_depot v3.0 -*- Perl -*-
#
# This script will go through the $depot directory and find files in
# specific subdirectories of various packages and make links in the
# corresponding $dest direcories (i.e. it will take the "lib", "man",
# "bin", "info", "include", etc. directories under any subdirectory
# of $depot and link all the files together under $dest/lib, $dest/man,
# etc.).
#
#************************************************************************
#
# Copyright (C) 1993-2003  The University of Texas at Austin.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
#    02111-1307, USA
#
#    Written by: Computer Science Division, Applied Research Laboratories,
#    University of Texas at Austin  opt-depot@arlut.utexas.edu
#
#***********************************************************************
# Written by Jeremy Thibeaux, Jonathan Abbey, Amy Shook
# October 8, 1993 - June 1, 1997
#
# v2.0
# Added modifications to allow opt_depot to create subdirecrories under
# /bin/lib/man/info/include to better accommodate package conflicts
# and added ability to access directory info from a configuration file
# Erik Grostic 15 May 1997
#
# v2.01
# Fixed a bug in procargs that had to do with the regex matching for
# re-defining the destination directory by using command line parameters.
# A -b option must now be given with the destination (or base) directory
# Erik Grostic 10 July 1997
#
# v3.0
# Reworked the recursive unification implementation to not get confused
# due to an under-specified regexp.  Made the per-package exclude files
# properly affect man page linking.  Reworked tons to use Opt_depot::Common,
# and modern Perl module function support.  Script is now position
# independent.  No more attempts at Perl 4 compatibility for us, no sir.
# Jonathan Abbey 25 July 2003
#
#
# Release: $Name:  $
# Version: $Revision: 1.23 $
# Last Mod Date: $Date: 2003/08/08 01:35:47 $
#
#####################################################################

use English;
use FindBin qw($RealBin);

use lib "$RealBin/../modules";
use Opt_depot::Common;

$version = "3.0";

## defaults #########################################################

# configuration file containing $dest, $depot and $logdir vars

$config_file = resolve($RealBin, "../etc/opt.config");

# this file is created by opt_depot when it makes a directory. only
# those directories containing this hidden file may be removed or
# collapsed by opt_clean

$opt_file = ".made_by_opt_depot";

#####################################################################
#
# Internal Variables
#
# %packexclude - Associative Array used to keep track of packages
#               that are to be excluded
#
# %exclude - Associative Array used to keep track of individual files
#           to be excluded
#
# %priority - Contains files and package names
#             that have priority lines associated with them.
#
#             All files and packages listed in the .priority file are
#             assigned a priority number, starting at 1 for the first
#             file mentioned in the .priority file and increasing for
#             each file listed in the .priority file.  In case of a
#             conflict, files with lower priority numbers in %priority
#             will be given priority over files with higher priority
#             numbers (files that are listed later in the .priority
#             file).
#
#             If a file is involved with a conflict but there are no
#             priority lines specified for that file, opt_depot will
#             check to see if any containing directory to which the
#             files belong have priority, and will maintain the link
#             whose package priority has the higher priority.
#
#####################################################################


#####################################################################
#
#                                                         needs_unify
#
# input: relative directory component to test ('include', etc.)
#
# uses: global @unify_list array
#
# output: returns 1 if the directory needs to be unified
#
#####################################################################
sub needs_unify {
  my ($param) = @_;

  my ($temp, $match, $p);

  # if we were given the -R flag, we always want to unify, whatever path
  # we're looking at

  if (exists $switches{'R'}) {
    return 1;
  }

  # failing -R, if we're not given the -r flag, we're not recursing,
  # so return 0

  if (!exists $switches{'r'}) {
    return 0;
  }

  # We are going to be sure that we suffix our search term and list of
  # to-be-unified subdirectories with trailing slashes if they lack
  # them.  The purpose of this is to prevent matching a directory
  # substring, as in lib matching libexec.

  $match = "$param";

  if ($match !~ /\/$/) {
    $match = "$param/";
  }

  foreach $p (@unify_list) {
    $temp = $p;

    if ($temp !~ /\/$/) {
      $temp = "$p/";
    }

    if ($param =~ /^$temp/) {
      return 1;
    }
  }

  return 0;
}

#########################################################################
#
#                                                             read_exfile
#
# input: name of an exclude file to process
#
# uses: %exclude %packexclude
#
# output: writes to associative arrays %exclude and %packexclude
#
# see the definition of %exclude and %packexclude at the top of this file
#
#########################################################################
sub read_exfile {
  my($exfile) = @_;

  if (-e $exfile) {
    open(EXFILE, $exfile) || die "Could not open $exfile";

    while (<EXFILE>){
      s/\s+$//;			# cut off trailing whitespace

      if (/^\s*#/) {
	next; # comment line - skip
      }

      if (/^\s*$/) {
	next; # blank line - skip
      }

      if (/^\s*\'/ || /^\s*\"/) {
	$_ = parsequoted($_, 0); # leave in escapes

	# if we have an unescaped :, treat that as a label separator,
	# and skip this entry

	if (!/(?:\\.|[^:])*$/){	
	  next;
	}

	# now take out escapes

	s/\\(.)/$1/g;

	# now see if we're excluding a qualified or nonqualified file name

	if (/^(\/.+)$/) {
	  # leading slash -- take this as an absolute path name
	  # $1 is the complete absolute path/filename

	  $exclude{"$1"}=1;
	} elsif (/^([^\/]+\/.+)$/) {
	  # No leading slash but there are embedded slashes..
	  # take this as a depot directory relative path
	  # $1 is the complete relative path and filename

	  $exclude{"$depot/$1"}=1;
	} elsif (/^([^\/]+)/) {
	  # No leading slash and no embedded slashes
	  # take this as a package name and version num
	  # if any is included.
	  # $1 is the complete package name

	  $packexclude{$1}=1;
	} else {
	  logprint("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	}
      } else {

	# no quotations, so we'll use the older, simpler parse logic

	if (/:/){	
	  next; # a labelled exclusion. Forget about it.
	}

	if (/^\s*(\/\S+)/) {
	  # leading slash -- take this as an absolute path name
	  # $1 is the complete absolute path/filename

	  $exclude{"$1"}=1;
	} elsif (/^\s*([^\/]+\/\S*)/) {
	  # No leading slash but there are embedded slashes..
	  # take this as a depot directory relative path
	  # $1 is the complete relative path and filename
	
	  $exclude{"$depot/$1"}=1;
	} elsif (/^\s*([^\/\s]+)/) {
	  # No leading slash and no embedded slashes
	  # take this as a package name and version num
	  # if any is included.
	  # $1 is the complete package name

	  $packexclude{$1}=1;
	} else {
	  logprint("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	}
      }
    }

    close(EXFILE);
  }
}

#########################################################################
#
#                                                            read_pack_ex
# input: $exfile - name of the per/package exclusion file
#
# uses: $depot
#       %exclude
#
# output: if a package is currently linked in $depot, and that package
#         has its own .exclude file, then the exclusions listed in that
#         file are added to the main exclusion hash.
#
#########################################################################
sub read_pack_ex {
  my(@allfiles,@contents);

  opendir (IN, $depot) || die "Could not open $depot";
  @contents = readdir(IN);
  closedir (IN);

  @allfiles = grep ((-e "$depot/$_") && ("$depot/$_" !~/^\./), @contents);

  foreach $file (@allfiles) {
    if (-e "$depot/$file/.exclude") {
      open(EXFILE, "$depot/$file/.exclude") || die "Could not open $depot/$file/.exclude";

      while (<EXFILE>){
	s/\s+$//;		# cut off trailing whitespace

	if (/^\s*#/) {
	  next;	  # comment line - skip
	}

	if (/^\s*$/) {
	  next; # blank line - skip
	}

	if (/^\s*\"/ || /^\s*\'/) {
	  $_ = parsequoted($_, 1);

	  if (/^(\/.+)$/) {
	    # leading slash -- take this as an absolute path name
	    # $1 is the complete absolute path/filename

	    $exclude{"$1"}=1;
	  } elsif (/^([^\/]+\/.+)$/) {
	    # No leading slash but there are embedded slashes..
	    # take this as a depot directory relative path
	    # $1 is the complete relative path and filename

	    $exclude{"$depot/$1"}=1;
	  } elsif (/^([^\/]+)$/) {
	    # No leading slash and no embedded slashes take this as a
	    # package name and version num if any is included.  Don't
	    # worry about those in per-package exclusions, opt_link
	    # looks at those at depot link time

	    next;
	  } else {
	    logprint("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	  }
	} else {
	  if (/^\s*(\/\S+)/) {
	    # leading slash -- take this as an absolute path name
	    # $1 is the complete absolute path/filename
	    $exclude{"$1"}=1;

	    if ($switches{'z'}) {
	      print"Excluding $1\n";
	    }
	  } elsif (/^\s*([^\/]+\/\S*)/) {
	    # No leading slash but there are embedded slashes..
	    # take this as a depot directory relative path
	    # $1 is the complete relative path and filename

	    $exclude{"$depot/$1"}=1;

	    if ($switches{'z'}) {
	      print"Excluding $depot/$1\n";
	    }
	  } elsif (/^\s*([^\/]+)$/) {
	    # No leading slash and no embedded slashes take this as a
	    # package name and version num if any is included.  Don't
	    # worry about those in per-package exclusions, opt_link
	    # looks at those at depot link time

	    next;
	  } else {
	    logprint ("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	  }
	}
      }

      close(EXFILE);
    }
  }
}

#########################################################################
#
#                                                            read_prifile
#
# input: name of a priority file to process
#
# uses: %priority
#
# output: writes to associative arrays %priority
#
# see the definition of %priority at the top of this file
#
#########################################################################
sub read_prifile {
  my($prifile) = @_;

  my($p);

  if (-e $prifile) {
    open (PRIFILE, $prifile) || die "Could not open $prifile";
    $p = 1;

    while (<PRIFILE>) {
      s/\s+$//;			# cut off trailing whitespace

      if (/^\s*#/) {
	next;			# skip comment line
      }

      if (/^\s*$/) {
	next;			# skip blank line
      }

      if (/^\s*\"/ || /^\s*\'/) {
	$_ = parsequoted($_, 1); # take out escapes

	if (/^(\/.*)/) {
	  # leading slash - absolute filename
	  # handle priority for individual file
	  # this clause handles absolute pathnames
	
	  $priority{"$1"}= ++$p;
	} else {
	  # this clause handles depot relative pathnames
	  $priority{"$depot/$1"}= ++$p;
	}
      } else {
	if (/^\s*(\/\S+)/) {
	  # leading slash - absolute filename
	  # handle priority for individual file
	  # this clause handles absolute pathnames
	
	  $priority{"$1"}= ++$p;
	} elsif (/^\s*(\S*)$/) {
	  # this clause handles depot relative pathnames
	  $priority{"$depot/$1"}= ++$p;
	}
      }
    }

    close(PRIFILE);
  }
}

#########################################################################
#
#                                                                 makedir
#
# input: name of a directory to create
#
# makedir() creates a directory and sets permissions on it to 755,
# honoring the 'n' switch which inhibits actual file operations for the
# sake of showing what would be done.
#
#########################################################################
sub makedir {
  my($dir) = @_;

  if (!($switches{'n'})) {
    mkdir($dir, 0755) || die "Could not make $dir";
    print (LOG "  Made:   directory $dir\n") if (!($switches{'q'}));
  }

  print ("  Make:   directory $dir\n") if ($switches{'v'});
}

#########################################################################
#
#                                                                 ourlink
#
# input: $package - name of package containing $file
#        $file - an absolute filename to possibly generate a link to
#        $link - the absolute filename of the link to be generated
#
# output: potentially generates a symbolic link from $link to $file
#         returns 1 if a new link was made, 0 otherwise
#
# ourlink() may not generate a link if an existing link has a higher
# priority, or if $file or the package that $file is under has been
# excluded due to a reference in the .exclude file.
#
# in general, ourlink() will not overwrite an existing link unless the
# .priority or .exclude file specifically gives the new link priority
# over the existing link.
#
#########################################################################
sub ourlink {
  my ($package, $file, $link) = @_;

  my ($return_value, $where, $oldpackage, $directory, $rwhere);

  $return_value = 0;

  # if we are supposed to exclude this file, skip linking it

  if (!pathcheck($file, *exclude) && !$packexclude{$package}) {

    # if it already exists then do not make link unless the file has
    # priority..  we'll check this down below if we need to.

    if (-l $link) {
      $rwhere=readlink($link);

      # extract the directory containing the file
      # referenced in $link

      $directory = extractdir($link);

      # find what the link's absolute target is.

      $where = resolve($directory, $rwhere);

      # $where is the target of an existing symlink in place
      # $file is the name of a file that we have been instructed to
      # link up into the $dest directory structure
      #
      # if $where does not equal $file, we need to look to see if we should
      # replace the existing link with a new link
      #
      # note that we never want to touch an existing link that points outside
      # of our $depot directory.. we'll check both of these conditions
      # with this if

      if (("$where" ne "$file") && ("$where" =~ /^$depot/)) {

	$where =~ /^$depot\/([^\/]*)/;
	$oldpackage = $1;

	$do_it = 0;
	$nope = 0;

	# if the old link points to an explicitly excluded target,
	# retarget the link

	if ($exclude{$where}) {
	  $do_it = 1;
	}

	# if the old link points to a target, in an excluded directory
	# tree, retarget the link

	if (!$do_it && pathcheck($where, *exclude)) {
	  $do_it = 1;
	}

	# if the new link target has priority and the old one doesn't,
	# retarget the link

	if (!$do_it && $priority{$file} && !$priority{$where}) {
	  $do_it = 1;
	}

	if (!$do_it && !$priority{$file} && $priority{$where}) {
	  $nope = 1;
	}

	# if the new link's priority is numerically lower than the old
	# one's, retarget the link
	#
	# if the old link's priority is numerically lower, then we
	# know for sure that we should keep the old link, and we won't
	# bother to do any more tests

	if (!$do_it && !$nope && $priority{$file} && $priority{$where}) {
	  if ($priority{$file} < $priority{$where}) {
	    $do_it = 1;
	  } else {
	    $nope = 1;
	  }
	}

	# if the new link's package has priority and the old link's
	# package doesn't, retarget the link

	if (!$nope && !$do_it && $priority{"$depot/$package"} && !$priority{"$depot/$oldpackage"}) {
	  $do_it = 1;
	}

	if (!$nope && !$do_it && !$priority{"$depot/$package"} && $priority{"$depot/$oldpackage"}) {
	  $nope = 1;
	}

	# if the new link's package is numerically lower than the old
	# one, retarget the link
	#
	# if the old link's package is numerically lower, then we know
	# for sure that we should keep the old link, and we won't
	# bother to do any more tests
		
	if (!$nope && !$do_it && $priority{"$depot/$package"} && $priority{"$depot/$oldpackage"}) {
	  if ($priority{"$depot/$package"} < $priority{"$depot/$oldpackage"}) {
	    $do_it = 1;
	  } else {
	    $nope = 1;
	  }
	}

	# if the new link is under a directory that has priority and
	# the old link is not, and we have not previously seen any
	# decisive reason to keep the old link, retarget the link

	if (!$nope && !$do_it && pathcheck($where, *priority) && !pathcheck($file, *priority)) {
	  $do_it = 1;
	}

	if (!$nope && !$do_it && !pathcheck($where, *priority) && pathcheck($file, *priority)) {
	  $nope = 1;
	}

	# if the new link's target is under a directory that has a
	# lower numeric priority value than the old link, retarget the
	# lin.  if the old link's target is under a directory that has
	# a lower numeric priority, then we know for sure that we
	# should keep the old link, and we won't bother to do any more
	# tests

	if (!$nope && !$do_it && pathcheck($where, *priority) && pathcheck($file, *priority)) {
	  if (pathcheck($file, *priority) < pathcheck($where, *priority)) {
	    $do_it = 1;
	  } else {
	    $nope = 1;
	  }
	}

	if ($do_it) {

	  # yay!  we get to replace the old link with a new link!

	  $rfile=$file;

	  # if we are in test mode, just show what we would do

	  if ($switches{'n'}) {
	    if ($switches{'v'}) {
	      print ("  rm:     $link->\n");
	      print ("          $where\n");
	      print ("  link:   $link ->\n");
	      print ("          $rfile\n");
	    }
	  } else {
	    if (!unlink($link)) {
	      logprint("  ERROR:  Could not remove $file", 0);
	    } else {
	      logprint("  rm:     $link->\n", 0);
	      logprint("          $where\n", 0);

	      push(@conflicts, "  $where (removed for: $file)\n");
	    }

	    if (!symlink($rfile, $link)) {
	      print ("  ERROR:  Could not make link to $file");
	      push(@conflicts, "  $file (link error)\n");
	    } else {
	      logprint("  link:   $link ->\n", 0);
	      logprint("          $rfile\n", 0);

	      $return_value = 1;
	    }
	  }
	} else {

	  # aw!  we don't get to make our link

	  if (pathcheck($where, *priority) || $priority{$oldpackage}) {
	    if ($switches{'z'}) {
	      # Hi! You've found the secret debug switch!
	      print (LOG "  OVERRIDDEN:  Conflict:  $file and \n");
	      print (LOG "                          $where (file with priority)\n");
	      print (LOG "               Did not make link to $file\n");
	    }
	  } else {
	    if (!($switches{'q'})) {
	      print (LOG "  ERROR:  Conflict:  $file and \n");
	      print (LOG "                     $where\n");
	      print (LOG "          Did not make link to $file\n");
	    }

	    if ($switches{'z'}) {
	      # No one can stop the secret debug switch!
	      print ("  ERROR:  Conflict:  $file and \n");
	      print ("                     $where\n");
	      print ("          Did not make link to $file\n");
	    }
	  }
		
	  # If this conflict wasn't due to a specific order to override in
	  # .priority or .exclude, then push it on to our conflicts list.

	  if (!$do_it) {
	    push(@conflicts,"  $file (conflict: $where)\n");
	  }
	}
      }

      # at this point, we had a link already existing where we wanted
      # to put one, and it either pointed where we wanted it to point,
      # or it pointed to a location out of our control.  In either
      # case, we won't do anything, and we'll end our if-else processing
      # here

    } else {

      # well, our prospective link-to-be, $link was not a symbolic link.
      # let's see if it exists at all.  if it exists and is not a symbolic
      # link, we can't touch it.

      if (-e $link){

	# it exists in some non-symlink fashion.  can't touch it.
	
	logprint("  ERROR:  $link already exists and is not a link\n", 0);
	logprint("          Did not make link to link $file\n", 0);

	push(@conflicts,"  $file (conflict: physical file)\n");
      } else {

	# okay, there's nothing standing in our way.  make the link.

	# if we're in test mode, just show the action to take

	if ($switches{'n'}) {
	  if ($switches{'v'}) {
	    print ("  link:   $link ->\n");
	    print ("          $file\n");
	  }
	} elsif (!symlink($file,$link)) {
	  logprint("  ERROR: Could not link $file\n", 0);
	  push (@conflicts, "  $file (link failed)\n");
	} else {
	  # yay!

	  logprint("  link:   $link ->\n", 0);
	  logprint("          $file\n", 0);

	  $return_value = 1;
	}			
      }
    }
  } elsif ($switches{'v'}) {
    # $file or $package was excluded.  let the user know if he is interested.

    if ($exclude{$file}) {
      print "  *** excluding $file\n";
    }
  }

  # ta-da!

  return $return_value;
}

#########################################################################
#
#                                                                 manlink
#
# input: $package - name of package to link man pages for
#
# output: potentially links man pages into $dest/man
#         if a link is made, global $mademan is set to 1
#
#########################################################################
sub manlink {
  my ($package) = @_;

  my ($file, @files, $mfile, @mfiles, $newsuf);

  # check under $package/man and link appropriate files under man1, man2, etc

  if (!-e "$depot/$package/man") {
    return;
  }

  # extract all files and directories that don't begin with .

  opendir (MAN, "$depot/$package/man") || print "Could not open $depot/$package/man.";
  @files=grep (!/^\./, readdir(MAN));
  closedir(MAN);

  for $file (@files) {

    if (pathcheck("$depot/$package/man/$file", *exclude)) {
      # do nothing.. don't link these manpages
	
      logprint("  Excluding man directory $depot/$package/man/$file/\n", 0);

      next;
    }

    # if file is a man directory then link all man files under it.
    # there really shouldn't be anything in the package's man
    # directory except man subdirectories (i.e., not cat directories),
    # but there might be readme's or something.  we'll ignore those.
	
    if (-d "$depot/$package/man/$file" && $file =~ /^man([0-9a-z]+)$/) {

      # we've got a man directory.  $1 is the man dir suffix

      $suf=$1;

      # make sure that the appropriate man and cat directories
      # exist in $dest/man..

      if (!(-e "$dest/man/man$suf")) {
	makedir("$dest/man/man$suf");
      }

      if (!(-e "$dest/man/cat$suf")) {
	makedir("$dest/man/cat$suf");
      }

      if (-d "$depot/$package/man/$file") {
			
	opendir (MDIR, "$depot/$package/man/$file") || print "Could not open $depot/$package/man/$file";
	@mfiles=grep (!/^\./, readdir(MDIR));
	closedir (MDIR);
			
	# link all man pages in this man directory into the
	# appropriate $dest directory
			
	for $mfile (@mfiles) {

	  if ($mfile =~ /\.([^\.]+)$/) {
				
	    $newsuf = $1;
				
	    # if the man page's filename doesn't end in the right
	    # suffix, warn the user and link it where it should
	    # go.
				
	    if ($newsuf ne $suf) {

	      # if the man page ends in a suffix different than
	      # that of the directory it is contained in,
	      # we'll want to correct this by placing it in
	      # the appropriate place.  If the directory
	      # does not exist, we'll want to create it.

	      if (!-e "$dest/man/man$newsuf") {
		makedir("$dest/man/man$newsuf");
	      }

	      if (!-e "$dest/man/cat$newsuf") {
		makedir("$dest/man/cat$newsuf");
	      }
	    }
				
	    if (ourlink($package, "$depot/$package/man/$file/$mfile", "$dest/man/man$newsuf/$mfile")) {
	      if ($newsuf ne $suf) {
		logprint("WARNING: suffix does not match directory for $depot/$package/man/$file/$mfile\n", 0);
		logprint("         Placed in $dest/man/man$newsuf\n", 0);
	      }
		
	      $mademan=1;
	    }
	  } else {
				
	    # the filename wasn't valid for a manpage

	    logprint("WARNING: file $depot/$package/man/$file/$mfile is not properly named for a man page..\n", 0);
	    logprint("         Not linking\n", 0);
	  }
	}
      }
    } else {
	
      # $file isn't a directory.. perhaps this means that this
      # package's man directory directly contains man pages rather
      # than man1..mann subdirectories.  check to see if we have a man
      # file with a recognizable extension, and link it into the
      # appropriate man subdirectory if so.
	
      if (-f "$depot/$package/man/$file" && $file =~ /\.([^\.]+)$/) {

	# file is a man page, link it to the appropriate man
	# directory.
			
	# note that this means that the man directory in this
	# package isn't structured properly, but we can deal with
	# it since we have the suffix to guide us.
			
	if (!(-e "$dest/man/man$1")) {
	  makedir("$dest/man/man$1");
	}

	if (!(-e "$dest/man/cat$1")) {
	  makedir("$dest/man/cat$1");
	}

	ourlink($package, "$depot/$package/man/$file", "$dest/man/man$1/$file");
	$mademan=1;
      }
    }
  }
}

#########################################################################
#
#                                                                prepdirs
#
# input: none
#
# uses:  globals @subdirs, $dest
#
# output: makes sure that all the desired directories exist in $dest
#         if prepdirs can't, it dies
#
#########################################################################
sub prepdirs {

  my ($subdir);

  for $subdir (@subdirs) {
    if (!-e "$dest/$subdir") {
      makedir("$dest/$subdir");
    } elsif (!-d "$dest/$subdir"){
      die "ERROR: $dest/$subdir is not a directory";
    }
  }

  if (!-e "$dest/man") {
    makedir("$dest/man");
  } elsif (!-d "$dest/man") {
    die "ERROR: $dest/man is not a directory";
  }
}

#########################################################################
#
#                                                          synthesize_dir
# input: a pathname
#
# uses: opt_file global variable name
#
# output: makes sure the specified directory exists. If it doesn't
#         then synthesize_dir makes it (along with any super-directories),
#         and places a .made_by_opt_depot tag in it.
#
#
#########################################################################
sub synthesize_dir {
  my ($file) = @_;

  my ($temp, @components);

  @components = split(/\//, $file);

  foreach $comp (@components) {
    $temp .= "$comp";

    if (! -d $temp && ($temp ne "")) {
      if (!$switches{'n'}) {
	mkdir($temp, 0755) || print "Could not make dir $temp\n";
	open (NEW, ">$temp/$opt_file") || die "Waaaah!!!";
	print NEW "This file is used by opt_depot to keep track of created directories.\n";
	print NEW "Please don't delete me.  Thanks.\n";
	close NEW;
      }

      if ($switches{'v'}) {
	print "MKDIR $temp\n";
      }
    }	

    $temp .= "/";  # add trailing /
  }
}

#########################################################################
#
#                                                             depth_first
# input: * Two packages for comparison
#        * The current directory under /$dest (ie lib, bin, info, include)
#
# uses: merge_list associative array, global @all_dirs
#
# output: depth_first takes two packages that have directory conflicts and
#         determines whether or not to merge these directories by utilizing
#         a depth_first recursive search and comparing the individual files
#         of the directory and sub-directories.
#
#
#########################################################################
sub depth_first {

  my ($new_pack, $old_pack, $opt_directory) = @_;

  my ($current_dir, @dirs, @files, @contents,$temp);
  my ($merge_target);

  # The first time we enter this function, we'll prep the @all_dirs
  # array with the name of the $new_pack.  This should be an
  # unqualified package name, as the assumption is that the bulk of
  # the opt_depot script is run after we do a chdir() into the $depot
  # directory.

  if ($#all_dirs < 0) {
    $all_dirs[0] = $new_pack;
  }

  # Now we continue with our depth-first traversal.  What we want to
  # do is to visit all subdirectories of $depot/$new_pack in
  # depth-first order.  When the recursive traversal phase is done, we
  # will see if any files exist in the subdirectory ($current_dir)
  # that we are visiting in both the new package we are linking in and
  # the old package that was already linked.  If so, and if the
  # priority supports any files from the new package to be linked,
  # we'll add an entry to %merge_list, indicating that that directory
  # needs to be created under $dest/$opt_directory

  $current_dir = pop (@all_dirs);

  opendir(DIR, $current_dir);
  @contents = readdir(DIR);
  closedir(DIR);

  @dirs = grep (("$current_dir/$_" !~ /\/\./) && (-d "$current_dir/$_"), @contents);

  foreach $dir (@dirs) {
    push (@all_dirs, "$current_dir/$dir");
  }

  if ($#all_dirs >= 0) {
    depth_first($new_pack, $old_pack, $opt_directory);
  }

  # now that we've finished recursing down, let's take a look at
  # what's in this directory and see if we need to add some merge
  # stuff here

  @files = grep (("$current_dir/$_" !~ /\/\./) && (!-d "$current_dir/$_"), @contents);

  foreach $file (@files) {
    $new_file = "$current_dir/$file";

    # copy $new_file string to $old_file, replacing the $new_pack
    # prefix with the $old_pack prefix, so that we can compare the
    # existence of files in the common relative location of the new
    # and old packages we're looking at merging

    $old_file = $new_file;
    $temp = $new_pack;
    $temp =~ s/(\W)/\\$1/g;	# backslash escape any special chars
    $old_file =~ s/^$temp/$old_pack/;

    if ($current_dir =~ /^$old_pack\/$opt_directory\/(.*)$/) {
      $merge_target = "$dest/$opt_directory/$1";
    } else {
      print "Error, couldn't break the '$opt_directory' prefix from '$current_dir'\n";
      print "old_pack is $old_pack, new_pack is $new_pack.\n";
      next;
    }

    if (!exists $merge_list{$merge_target}) {
      if ((-e $new_file && !-e $old_file) ||
	  (pathcheck($new_file, *priority) < pathcheck($old_file, *priority))) {
	if (pathcheck("$new_file", *exclude)) {
	  logprint("\n  *** EXCLUDING DIRECTORY: $new_file\n\n", 0);
	} else {
	  $merge_list{$merge_target} = 1;
	}
      }
    }
  }
}

#########################################################################
#
#                                                                 link_me
#
# input: $sub_dir - name of the current directory where link_me is being
#                       called
#        $opt_directory - name of the first directory under /$dest that we are
#        currently under (ie lib, info, include, bin...)
#        @pack_list - list of packages that are ready to be considered for
#                     linking under $dest directory
#
# output: potentially creates links to files under $dest directory
#
# link_me carries out the recursive linking of files into the bin lib info
# and include directories under $dest
#
#########################################################################

sub link_me {
  my ($subdir,$opt_directory, @pack_list) = @_;

  my (%pack_hash,$common_dir,@temp_list);
  my ($i,$old_pack,$new_pack,$temp);

  logprint("LINKING:  $subdir\n", 0);

  for $package (@pack_list) {
    if ($packexclude{$package} || pathcheck("$depot/$package/$subdir", *exclude)) {
      logprint("\n  *** EXCLUDING DIRECTORY: $depot/$package/$subdir\n\n", 0);

      next;
    }

    if (-d "$depot/$package/$subdir") {
      opendir(SUBDIR, "$depot/$package/$subdir") || print "Could not open $depot/$package/$subdir\n";

      # extract all files and directories in
      # $package/$subdir that don't begin with .

      @files= grep (!/^\./, readdir(SUBDIR));

      closedir(SUBDIR);

      for $file (@files) {
	undef @temp_list;

	if (-d "$depot/$package/$subdir/$file") {
	  # we're looking at a subdirectory.. unify?

	  $new_pack = "$package/$subdir/$file";
	  $common_dir = "$subdir/$file";

	  if (-l "$dest/$subdir/$file" ) {
	    # link already exists in $dest

	    $old_pack = readlink("$dest/$common_dir");

	    if ($old_pack =~ /^$depot\/?(.*)/) {
	      $old_pack = $1;
	    } else {
	      # old link points outside of the depot tree, leave it alone
	      next;
	    }

	    # $old_pack now has a depot directory-relative path from
	    # the old link

	    if ($new_pack ne $old_pack) {
	      undef %merge_list;

	      # check and see if a merge is actually required

	      if (needs_unify($subdir)) {
		depth_first($new_pack, $old_pack, $opt_directory);

		# if we've decided to merge things, let's remove the
		# old symlink and create as many subdirectories as
		# necessary.  We'll create records in %pack_hash of
		# directories we'll need to continue to recurse down
		# into in order to possibly do deeper directory
		# unification

		if (defined %merge_list) {
		  @temp_list[0] = $old_pack;
		  @temp_list[1] = $new_pack;
		  $pack_hash{$common_dir} = [ @temp_list ];
		  unlink("$dest/$common_dir"); # remove old symlink

		  foreach $dir (keys %merge_list) {
		    synthesize_dir($dir);
		  }

		  next; # we've made directories, we'll do the linking through recursion
		}
	      }
	    }
	  } elsif (-d "$dest/$subdir/$file") {
	    # there is already a subdirectory built for us.
	    # Cool.  We'll still need to record the subdirectories
	    # for further recursion.

	    if (! exists $pack_hash{$common_dir}) {
	      @temp_list[0] = $new_pack;
	      $pack_hash{$common_dir} = [ @temp_list ];
	    } else {
	      @temp_list = @{ $pack_hash{$common_dir}};
	      push (@temp_list, $new_pack);
	      $pack_hash{$common_dir} = [ @temp_list ];
	    }

	    next; # ditto -- wait to recurse to link
	  }
	} # end if (-d "$depot/$package/$subdir/$file")

	# no subdirectory unification to worry about, just look to see
	# if the new file or directory ($depot/$package/$subdir/$file
	# can be a directory) has priority or exclusion rights over
	# the current "$dest/$subdir/$file", if any.  if so, we'll
	# unlink the old and link the new.

	ourlink($package, "$depot/$package/$subdir/$file", "$dest/$subdir/$file");
      }
    }
  }

  #end loop over packages

  #
  # make recursive call to link_me if necessary..
  #

  if (($switches{'r'} || $switches{'R'}) && defined %pack_hash) {
    # we've got a directory conflict. let's call link_me again

    foreach $common_dir (keys %pack_hash) {
      #print"\tSubdirectory: $common_dir\n";
      @pack_list = @{ $pack_hash{$common_dir} };

      foreach $element (@pack_list) {
	$temp = $common_dir;
	$temp =~ s/(\W)/\\$1/g;	# quote meta-chars
	$element =~ s/\/$temp//; # removes the common directory
	# name from the package
	#print"\tElement: $element\n";
      }

      # Here we're checking to see if the current directory is
      # a candidate for recursive unification. It's gotta be
      # in the @unify_list array that's specified in the defaults

      if (needs_unify($common_dir)) {
	link_me($common_dir,$opt_directory, @pack_list); # ah, the mysteries of recursion...
      }
    }	
  }
} #link_me

################################################################################
#                                                                              #
#                                     MAIN                                     #
#                                                                              #
################################################################################

$usage_string =<<'ENDUSAGE';
Usage:  opt_depot [-svnqmrR] [-f\"config file\"] [-d\"depot dir\"]
                  [-l\"log dir\"] [-b\"software base dir\"]
ENDUSAGE

read_prefs($usage_string, $config_file, "svnqmrR", @ARGV);
init_log("opt_depot");

logprint("\nopt_depot $version\n\n", 1);

if (!check_lock("opt_depot")) {
  logprint("Can't create lockfile, aborting\n", 1);
  exit(1);
}

read_exfile("$dest/.exclude");	# initialize exclude hash from primary file
read_pack_ex();			# add per-package exclusions to exclude hash
read_prifile("$dest/.priority");
prepdirs();			# get our dirs set up

##
## MAIN PROCESS
##

# get a list of packages installed in $depot.. we don't
# want to deal with invisible files or the . and .. dirs

chdir $depot || die "Could not cd to $depot";

opendir (DEPOT, $depot) || die "Could not open $depot";
@packages=grep(-d && !/^\./, readdir(DEPOT));
closedir(DEPOT);

foreach $subdir (@subdirs) {
  # This is the name of the primary directory
  # we're working in (ie lib, bin, info, etc).

  $opt_directory = $subdir;

  if ($subdir ne "man") {
    link_me($subdir,$opt_directory, @packages);
  } else {
    logprint("LINKING:  man\n",0);

    foreach $package (@packages) {
      if (!$packexclude{$package}) {
	manlink($package);
      }
    }
  }
}

#
# list uncreated links
#

if ($conflicts[0]) {
  logprint("\nUNMADE OR UNDONE LINKS:\n", 0);
  logprint("@conflicts", 0);
}

#
# rebuild catman database if we touched the manpages
#

if ($mademan && $switches{'m'} && -x "/usr/bin/catman") {
  logprint("  Rebuilding man page indices\n", 0);
  system("/usr/bin/catman -w -M $dest/man");
  logprint("  Man page indices rebuilt \n", 0);
}

clear_lock();
close_log();
