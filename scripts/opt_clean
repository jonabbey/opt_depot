#
#
# opt_clean v3.0 -*- Perl -*-
#
# This is a perl script that will find all the links under
# $dest and ensures that the files pointed to under $depot
# exist and are not excluded in the exclude file.  The
# script will remove any obsolete links that target the
# $depot directory, but which do not have valid targets..
#
#***********************************************************************
#
# Copyright (C) 1997-2003  The University of Texas at Austin.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#    Written by: Computer Science Division, Applied Research Laboratories,
#    University of Texas at Austin  opt-depot@arlut.utexas.edu
#
#***********************************************************************
# Written by Jeremy Thibeaux, Jonathan Abbey, Amy Shook
# October 8, 1993 - June 1, 1997
#
# v2.0
# Added modifications to handle recursive cleaning within a driectory
# and to access directory info from a configuration file
# Erik Grostic 15 May 1997
#
# v2.01
# Fixed a bug in procargs that had to do with the regex matching for
# re-defining the destination directory by using command line parameters.
# A -b option must now be given with the destination (or base) directory
# Erik Grostic 10 July 1997
#
#
# Release: $Name:  $
# Version: $Revision: 1.7 $
# Last Mod Date: $Date: 2003/08/02 03:27:54 $
#
#########################################################################

use English;
use FindBin qw($RealBin);

use lib "$RealBin/../modules";
use Opt_depot::Common;

$version = "3.0";

## defaults #########################################################

# none of these directories should have trailing slashes

# Note: The definitions for .exclude can be found under MAIN


$config_file = "$RealBin/../etc/opt.config";
                                        # configuration file containing
                                        # $dest, $depot and $logdir vars

$opt_file = ".made_by_opt_depot"; # this file is created by opt_depot
                                  # when it makes a directory. only these
                                  # directories may be removed or collapsed

#########################################################################
#
#                                                             read_exfile
#
# input: name of am exclude file to process
#
# output: writes to associative arrays %exclude and %packexclude
#
#
#########################################################################
sub read_exfile {
  my($exfile) = @_;

  my $tmpstr;

  if (-e $exfile) {
    open(EXFILE, $exfile) || die "Could not open $exfile";

    while (<EXFILE>) {
      s/\s+$//;			# cut off any trailing whitespace

      if (/^\s*#/) {
	next;			# comment
      }

      if (/^\s*$/) {
	next;			# blank line
      }

      # if the string is quoted, pre-process the quotes

      if (/^\s*\"/ || /^\s*\'/) {
	$_ = parsequoted($_, 1); # process escapes

	if (/^(\/.+)$/) {
	  # leading slash -- take this as an absolute path name
	  # $1 is the complete absolute path/filename

	  $exclude{"$1"}=1;
	} elsif (/^([^\/]+\/.+)$/) {
	  # No leading slash but there are embedded slashes..
	  # take this as a depot directory relative path
	  # $1 is the complete relative path and filename

	  $exclude{"$depot/$1"}=1;
	} elsif (/^([^\/]+)$/) {
	  # No leading slash and no embedded slashes
	  # take this as a package name and version num
	  # if any is included.
	  # $1 is the complete package name

	  $packexclude{$1}=1;
	} else {
	  logprint("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	}
      } else {
	# We didn't have a quoted string, assume that whitespace
	# will terminate

	if (/^\s*(\/\S+)$/) {
	  # leading slash -- take this as an absolute path name
	  # $1 is the complete absolute path/filename

	  $exclude{"$1"}=1;
	} elsif (/^\s*([^\/]+\/\S*)$/) {
	  # No leading slash but there are embedded slashes..
	  # take this as a depot directory relative path
	  # $1 is the complete relative path and filename

	  $exclude{"$depot/$1"}=1;
	} elsif (/^\s*([^\/]+)$/) {
	  # No leading slash and no embedded slashes
	  # take this as a package name and version num
	  # if any is included.
	  # $1 is the complete package name

	  $tmpstr = $1;

	  if ($tmpstr =~ /^(\S*)/) {
	    $packexclude{$1}=1;
	  }
	} else {
	  logprint("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	}
      }
    }

    close(EXFILE);
  }
}

#########################################################################
#
#                                                            read_pack_ex
#
# input:
#
# uses: $depot
#       %exclude
#
# output: if a package is currently linked in $depot, and that package
#         has its own .exclude file, then the exclusions listed in that
#         file are added to the main exclusion hash.
#
#########################################################################
sub read_pack_ex {
  my(@allfiles,@contents);

  opendir(IN, $depot) || die "Could not open $depot";
  @contents = readdir(IN);
  closedir(IN);

  @allfiles = grep ((-e "$depot/$_") && (!/^\.\.?/), @contents);

  foreach $file (@allfiles) {
    if (-e "$depot/$file/.exclude") {
      open(EXFILE, "$depot/$file/.exclude") || die "Could not open $depot/$file/.exclude";

      while (<EXFILE>) {
	s/\s+$//;			# cut off any trailing whitespace

	if (/^\s*#/) {
	  next;			# comment
	}

	if (/^\s*^/) {
	  next;			# blank line
	}

	# if the string is quoted, pre-process the quotes

	if (/^\s*\"/ || /^\s*\'/) {
	  $_ = parsequoted($_, 1);

	  if (/^(\/.+)$/) {
	    # leading slash -- take this as an absolute path name
	    # $1 is the complete absolute path/filename

	    $exclude{"$1"}=1;
	  } elsif (/^([^\/]+\/.+)$/) {
	    # No leading slash but there are embedded slashes..
	    # take this as a depot directory relative path
	    # $1 is the complete relative path and filename

	    $exclude{"$depot/$1"}=1;
	  } elsif (/^([^\/]+)/) {
	    # No leading slash and no embedded slashes
	    # take this as a package name and version num
	    # if any is included.

	    # Don't worry about these in per-package exclusions

	    next;
	  } else {
	    logprint("  ERROR:  bad entry in .exclude file \"$_\"", 1);
	  }
	} else {
	  # We didn't have a quoted string, assume that whitespace
	  # will terminate

	  if (/^\s*(\/\S+)/) {
	    # leading slash -- take this as an absolute path name
	    # $1 is the complete absolute path/filename

	    $exclude{"$1"}=1;
	  } elsif (/^\s*([^\/]+\/\S*)/) {
	    # No leading slash but there are embedded slashes..
	    # take this as a depot directory relative path
	    # $1 is the complete relative path and filename

	    $exclude{"$depot/$1"}=1;
	  } elsif (/^\s*([^\/\s]+)/) {
	    # No leading slash and no embedded slashes
	    # take this as a package name and version num
	    # if any is included.
	    #
	    # Don't worry about these in per-package
	    # exclusions.. opt_link will have handled them

	    next;
	  } else {
	    logprint("  ERROR:  bad entry in .exclude file \"$_\"", 0);
	  }
	}
      }

      close(EXFILE);
    }
  }
}

#########################################################################
#
#                                                                  rmdirs
#
# input: the pathname of a directory to scan through
#
# rmdirs() scans through the supplied directory, removing any symbolic
# links that point to non-existent files in the $depot directory tree.
#
# rmdirs() will also remove links pointing to a package's tree if that
# package has been placed in the .exclude file in the $dest directory.
#
#########################################################################
sub rmdirs{
  my ($dir) = @_;

  my (@dirs, $dirs, $reslink, $where, $link, @links, @contents);
  my (@real_files,$result,$all_same,$first,$second);

  opendir(DIR, "$dir") || die "Could not open $dir";
  @contents = readdir(DIR);
  @real_files = grep (!/^\./, @contents);
  closedir(DIR);

  if ($#real_files<0) {
    # directory contains no visible files -- annihilate it

    # but only if the -r option is not in effect and the dir
    # contains an $opt_file

    if (($switches{'r'}) && (-e "$dir/$opt_file")) {
      logprint("Removing empty directory: $dir\n", 1);

      if (!killdir("$dir")) {
	logprint("Error: Could not remove $dir\n", 1);
      }

      return "** empty **"; # let's blow this popsicle stand...
    }
  }

  # get all links

  @links = grep (-l "$dir/$_", @contents);

  # get all non-symlink non-{.|..} subdirs

  @dirs = grep ((!/^\.\.?$/) && !(-l "$dir/$_") && (-d _), @contents);

  # note that we do -d _ above as an optimization, so that perl doesn't
  # go and stat $dir/$_ a second time when it already has the
  # stat info from the -l check that it had to do immediately before..

  # remove bad links

  # 2.0 - and test to see if all the links point to a single package.

  if ($#dirs>=0) {
    $all_same = 0;
  } elsif (defined @links) {
    $all_same = 1;		# all_same is true if all the links point to the
				# same package. Assume true until proven otherwise.

    # get location of first package as a comparison value.

    $first = extractdir(readlink("$dir/@links[0]"));
    removelastslash($first);

    foreach $link (@links) {
      $second = extractdir(readlink("$dir/$link"));
      removelastslash($second);

      if ($first ne $second) {
	$all_same = 0; # links do not all point to same place...
	last;
      }
    }
  }

  if ($all_same) {
    return $first;		# this returns the value of the common link.
				# that way we can collapse the directory.
  }

  for $link (@links) {

    $where = readlink("$dir/$link");
    $reslink = resolve($dir, $where);

    # $reslink is a string containing the filename of
    # the resolved absolute target of the symlink $dir/$link

    if ($reslink =~ /^$depot\//) {

      # yay!  the link points into the $depot tree.. we can
      # maybe blow it away if it is old

      $reslink =~ /^$depot\/([^\/]*)/;

      # $1 is the package name..

      # check to see if the target doesn't exist first, then if the
      # target file has been excluded by the .exclude file, then if
      # the target package has been excluded by the .exclude file
      #
      # Note that we don't try and deal with removing links obviated
      # by a .priority file.. we leave all priority handling for
      # opt_depot to handle

      if (!(-e $reslink || -l $reslink) || $exclude{$reslink} ||
	  $packexclude{$1} || pathcheck($reslink, *exclude)) {
	if (!unlink("$dir/$link")) {
	  logprint("  ERROR: could not remove $dir/$link", 1);
	} else {
	  logprint("  removed $dir/$link -> $reslink\n", 0);
	}
      }
    }
  }

  # check the directories in this directory
  # recursively..
  #
  # we don't want to scan down into /opt/depot

  for $dirs (@dirs) {
    if ("$dir/$dirs" ne $depot) {
      $result = rmdirs("$dir/$dirs");

      # here's where we evaluate the return values from the recursion

      if (($result ne "** good **") && ($result ne "** empty **") &&
	  ($result ne "")) {

	# we should collapse this directory, but only if the $opt_file
	# exists, and if the -r option is employed

	if (($switches{'r'}) && (-e "$dir/$dirs/$opt_file")) {
	  logprint("Collapsing Directory: $dir/$dirs\n",1);

	  if (killdir("$dir/$dirs")) {
	    symlink ("$result", "$dir/$dirs");
	  } else {
	    logprint("Couldn't successfully remove $dir/$dirs!\n", 1);
	  }
	}
      }
    }
  }

  return "** good **"; # everything's beautiful in our little world.
}

################################################################################
#                                                                              #
#                                     MAIN                                     #
#                                                                              #
################################################################################

$usage_string =<<'ENDUSAGE';
Usage:  opt_clean [-svqr] [-f\"config file\"] [-d\"depot dir\"]
                  [-l\"log directory\"] [\b\"base directory\"]
ENDUSAGE

read_prefs($usage_string, $config_file, "svqr", @ARGV);
init_log("opt_clean $version");

if (!check_lock("opt_clean")) {
  logprint("Can't create lockfile, aborting\n", 1);
  close_log();
  exit(1);
}

$exclude = "$dest/.exclude"; # Name of the .exclude file

read_exfile($exclude);
read_pack_ex();

chdir $dest || die "could not change to $dest";
foreach $subdir (@subdirs) {
  rmdirs("$dest/$subdir");
}

clear_lock();
close_log();
