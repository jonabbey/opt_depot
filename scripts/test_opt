# test_opt v3.0 -*- Perl -*-
#
# Testing harness for the opt_depot scripts
#
#************************************************************************
#
# Copyright (C) 1993-2003  The University of Texas at Austin.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
#    02111-1307, USA
#
#    Written by: Computer Science Division, Applied Research Laboratories,
#    University of Texas at Austin  opt-depot@arlut.utexas.edu
#
#***********************************************************************
# Written by Jonathan Abbey
# 10 September 2003
#
# Release: $Name:  $
# Version: $Revision: 1.27 $
# Last Mod Date: $Date: 2003/09/20 07:57:05 $
#
#####################################################################

use English;
use FindBin qw($RealBin $RealScript);

use lib "$RealBin/../modules";
use Opt_depot::Common;

$version = "3.0";

$| = 1;				# auto-flush

## defaults #########################################################

$test_root = "/tmp/opt_suite-$version";
$test_dir = "$test_root/base";
$test_logdir = "$test_root/log";
$test_etc = "$test_root/etc";

if (defined $ENV{'PERLLOC'}) {
  $perlloc = $ENV{'PERLLOC'};
} else {
  $perlloc = '/usr/bin/perl';	# default
}

#####################################################################

$testconfA =<< "ENDTESTCONF1";
Base: $test_dir
Depot: $test_dir/depot
Log: $test_logdir/opt_depot.log
SiteFile: $test_etc/sites
Subdirs: bin,include,info,lib,man
AlwaysRecurse: No
Recurse: include,lib,info
ENDTESTCONF1

$testsitesA =<< "ENDSITES1";
ENDSITES1

%siteA = (label => 'local',
	  path => "$test_dir/sites/local",
	  contents => [
		       {name     => 'packA-1.0',
			files    => ['bin/hi',
				     'lib/test.so'],
			excludes => ['packB-1.0']},
		       {name     => 'packB-1.0',
			files    => ['bin/hi',
				     'lib/test.so',
				     'lib/test2.so']},
		       {name     => 'packC-1.0',
			files    => ['bin/hiC',
				     'man/manl/hiC.l',
				     'include/hiC.h',
				     'lib/testC.so'],
			excludes => ['packC-0.5']},
		       {name     => 'packC-0.5',
			files    => ['bin/hiC',
				     'man/manl/hiC.l',
				     'include/hiC.h',
				     'lib/testC.so']},
		       {name     => 'packX-1.2',
			files    => ['bin/asteroids',
				     'README.asteroids',
				     'man/man1/asteroids.1']}
		      ]);

%siteB = (label => 'localB',
	  path => "$test_dir/sites/localB",
	  contents => [
		       {name     => 'packA-2.0',
			files    => ['bin/hi',
				     'lib/test.so'],
			excludes => ['packA-1.0']},
		       {name     => 'packB-2.0',
			files    => ['bin/hi',
				     'lib/test.so',
				     'lib/test2.so'],
			excludes => ['packB-1.0']},
		       {name     => 'packC-2.0',
			files    => ['bin/hiC',
				     'man/manl/hiC.l',
				     'include/hiC.h',
				     'lib/testC.so'],
			excludes => ['packC-1.0']},
		       {name     => 'packY-4.51',
			files    => ['ARLUT_README',
				     'bin/space invaders',
				     'man/man5/space.5']}
		      ]);

%test0 = (label  => 'Simple single-package link test',
	  root   => $test_dir,
	  start  => ['depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packA/man/manl/test.l'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/', 'man/manl/',
		     'bin/hi->depot/packA/bin/hi',
		     'lib/perl5->depot/packA/lib/perl5/',
		     'include/test.h->depot/packA/include/test.h',
		     'man/manl/test.l->depot/packA/man/manl/test.l'],
	  endex  => ['^depot\/$', '^man\/cat.*\/'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_depot',
	  error_count => 0);

%test1 = (label  => 'First exclusion test',
	  root   => $test_dir,
	  start  => ['depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packA/bin/hi',
		     'lib/perl5->depot/packA/lib/perl5/',
		     'include/test.h->depot/packA/include/test.h'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_depot',
	  exclude => 'packB',
	  error_count => 0);

%test2 = (label  => 'Elementary recursion test',
	  root   => $test_dir,
	  start  => ['depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h',
		     'depot/packC/include/test.h',
		     'depot/packC/lib/perl5/spam'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packB/bin/hi',
		     'lib/perl5/', 'lib/perl5/.made_by_opt_depot',
		     'lib/perl5/spam/', 'lib/perl5/spam/.made_by_opt_depot',
		     'lib/perl5/spam/x.pl->depot/packA/lib/perl5/spam/x.pl',
		     'lib/perl5/spam/y.pl->depot/packB/lib/perl5/spam/y.pl',
		     'include/test.h->depot/packB/include/test.h'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_depot',
	  priority => 'packB',
	  error_count => 0);


%test3 = (label  => 'Multi-level recursion test',
	  root   => $test_dir,
	  start  => ['depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/packB.so',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h',
		     'depot/packC/include/test.h',
		     'depot/packC/lib/perl5/spam/mod/packC.pm'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packB/bin/hi',
		     'lib/packB.so->depot/packB/lib/packB.so',
		     'lib/perl5/', 'lib/perl5/.made_by_opt_depot',
		     'lib/perl5/spam/', 'lib/perl5/spam/.made_by_opt_depot',
		     'lib/perl5/spam/x.pl->depot/packA/lib/perl5/spam/x.pl',
		     'lib/perl5/spam/y.pl->depot/packB/lib/perl5/spam/y.pl',
		     'lib/perl5/spam/mod->depot/packC/lib/perl5/spam/mod',
		     'include/test.h->depot/packB/include/test.h'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_depot',
	  priority => 'packB',
	  error_count => 0);

%test4 = (label  => 'Priority link replacement test',
	  root   => $test_dir,
	  start  => ['bin/hi->depot/packA/bin/hi',
		     'include/test.h->depot/packA/include/test.h',
		     'lib/perl5->depot/packA/lib/perl5/',
		     'depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/packB.so',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h',
		     'depot/packC/include/test.h',
		     'depot/packC/lib/perl5/spam/mod/packC.pm'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packB/bin/hi',
		     'lib/packB.so->depot/packB/lib/packB.so',
		     'lib/perl5/', 'lib/perl5/.made_by_opt_depot',
		     'lib/perl5/spam/', 'lib/perl5/spam/.made_by_opt_depot',
		     'lib/perl5/spam/x.pl->depot/packA/lib/perl5/spam/x.pl',
		     'lib/perl5/spam/y.pl->depot/packB/lib/perl5/spam/y.pl',
		     'lib/perl5/spam/mod->depot/packC/lib/perl5/spam/mod',
		     'include/test.h->depot/packB/include/test.h'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_depot',
	  priority => 'packB',
	  error_count => 0);

%test5 = (label  => 'Exclude link replacement test',
	  root   => $test_dir,
	  start  => ['bin/hi->depot/packA/bin/hi',
		     'include/test.h->depot/packA/include/test.h',
		     'lib/perl5->depot/packA/lib/perl5/',
		     'depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/packB.so',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h',
		     'depot/packC/include/test.h',
		     'depot/packC/lib/perl5/spam/mod/packC.pm'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packB/bin/hi',
		     'lib/packB.so->depot/packB/lib/packB.so',
		     'lib/perl5/', 'lib/perl5/.made_by_opt_depot',
		     'lib/perl5/spam/', 'lib/perl5/spam/.made_by_opt_depot',
		     'lib/perl5/spam/y.pl->depot/packB/lib/perl5/spam/y.pl',
		     'lib/perl5/spam/mod->depot/packC/lib/perl5/spam/mod',
		     'include/test.h->depot/packB/include/test.h'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_depot',
	  exclude => 'packA',
	  error_count => 0);

%test6 = (label  => 'Simple clean test',
	  root   => $test_dir,
	  start  => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'depot/',
                     'bin/hi->depot/packA/bin/hi',
		     'lib/perl5->depot/packA/lib/perl5/',
                     'include/test.h->depot/packA/include/test.h'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_clean',
	  error_count => 0);

%test7 = (label  => 'Simple exclude test',
	  root   => $test_dir,
	  start  => ['bin/', 'lib/', 'man/', 'include/', 'info/',
                     'depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
                     'bin/hi->depot/packA/bin/hi',
		     'lib/perl5->depot/packA/lib/perl5/',
                     'include/test.h->depot/packA/include/test.h'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_clean',
	  exclude => 'packA',
	  error_count => 0);

%test8 = (label  => 'Recursive clean test',
	  root   => $test_dir,
	  start  => ['bin/', 'lib/', 'man/', 'include/', 'info/',
                     'depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h',
                     'bin/hi->depot/packB/bin/hi',
                     'lib/perl5/', 'lib/perl5/.made_by_opt_depot',
                     'lib/perl5/spam/', 'lib/perl5/spam/.made_by_opt_depot',
                     'lib/perl5/spam/x.pl->depot/packA/lib/perl5/spam/x.pl',
                     'lib/perl5/spam/y.pl->depot/packB/lib/perl5/spam/y.pl',
                     'include/test.h->depot/packA/include/test.h'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packB/bin/hi',
		     'lib/perl5->depot/packB/lib/perl5/'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_clean',
	  exclude => 'packA',
	  error_count => 0);


%test9 = (label  => 'Clean and link test',
	  root   => $test_dir,
	  start  => ['bin/', 'lib/', 'man/', 'include/', 'info/',
                     'depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h',
		     'depot/packC/lib/packC.so',
                     'bin/hi->depot/packA/bin/hi',
		     'bin/not_really->depot/packC/bin/not_really',
                     'lib/perl5/', 'lib/perl5/.made_by_opt_depot',
                     'lib/perl5/spam/', 'lib/perl5/spam/.made_by_opt_depot',
                     'lib/perl5/spam/x.pl->depot/packA/lib/perl5/spam/x.pl',
                     'lib/perl5/spam/y.pl->depot/packB/lib/perl5/spam/y.pl',
                     'include/test.h->depot/packA/include/test.h'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packB/bin/hi',
		     'lib/packC.so->depot/packC/lib/packC.so',
		     'lib/perl5->depot/packB/lib/perl5/',
		     'include/test.h->depot/packB/include/test.h'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_setup',
	  exclude => 'packA',
	  priority => 'packB',
	  error_count => 0);


%test9 = (label  => 'Clean and link test',
	  root   => $test_dir,
	  start  => ['bin/', 'lib/', 'man/', 'include/', 'info/',
                     'depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h',
		     'depot/packC/lib/packC.so',
                     'bin/hi->depot/packA/bin/hi',
		     'bin/not_really->depot/packC/bin/not_really',
                     'lib/perl5/', 'lib/perl5/.made_by_opt_depot',
                     'lib/perl5/spam/', 'lib/perl5/spam/.made_by_opt_depot',
                     'lib/perl5/spam/x.pl->depot/packA/lib/perl5/spam/x.pl',
                     'lib/perl5/spam/y.pl->depot/packB/lib/perl5/spam/y.pl',
                     'include/test.h->depot/packA/include/test.h'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packB/bin/hi',
		     'lib/packC.so->depot/packC/lib/packC.so',
		     'lib/perl5->depot/packB/lib/perl5/',
		     'include/test.h->depot/packB/include/test.h'],
	  endex  => ['^depot\/$', '^\.priority$', '^\.exclude$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
          sitedefs => [\%siteA, \%siteB],
	  action => 'opt_setup',
	  exclude => 'packA',
	  priority => 'packB',
	  error_count => 0);

@tests = (\%test0, \%test1, \%test2, \%test3,
	  \%test4, \%test5, \%test6, \%test7,
	  \%test8, \%test9);

#####################################################################


#########################################################################
#
#                                                               init_site
#
# input: a reference to a site volume definition
#
# init_site reads the definition for a site volume and creates it..
# this includes the site volume's directory, its package contents, and
# any per-package .exclude files.
#
# returns 1 on success, 0 on failure
#
#########################################################################

sub init_site {
  my ($site_href) = @_;

  my (@site_ary, $pack, @package_files, $file, @excl_ary, $exclusion);
  local (*OUT);

  if (!create_dir($site_href->{'path'})) {
    return 0;
  }

  @site_ary = @$site_href->{'contents'};

  foreach $pack (@site_ary) {
    $path_root = $site_href->{'path'} . '/' . $pack->{'none'};
    create_dir($path_root);

    @package_files = @$pack->{'files'};

    foreach $file (@package_files) {
      if ($file =~ /\/$/) {
	create_dir($path_root . '/' . $file);
      } else {
	touch($path_root . '/' . $file);
      }
    }

    if (defined $pack->{'excludes'}) {
      @excl_ary = @$pack->{'excludes'};

      if (!open(OUT, "$path_root/.exclude")) {
	print "Error, could not create .exclude file in $path_root\n";
	return 0;
      }

      foreach $exclusion (@excl_ary) {
	print OUT "$exclusion\n";
      }

      close(OUT);
    }
  }

  return 1;
}

#########################################################################
#
#                                                              setup_test
#
# input: a reference to one of our test descriptions
#
# setup_test does everything required to create a test environment for
# a given test, including creating a fresh directory structure.
#
#########################################################################

sub setup_test {
  my ($href) = @_;

  my ($label, $rootdir, $startary, $label, $element, $newpath);

  $label = $href->{'label'};
  $rootdir = $href->{'root'};
  $startary = $href->{'start'};

  killdir($rootdir);
  create_dir($rootdir);
  chdir($rootdir);

  if (defined $href->{'sitedefs'}) {
    @site_ary = @$href->{'sitedefs'};

    foreach $site (@site_ary) {
      init_sit($site);
    }
  }

  foreach $element (@$startary) {

    if ($rootdir =~ /\/$/) {
      $newpath = $rootdir . $element;
    } else {
      $newpath = $rootdir . "/" . $element;
    }

    if ($newpath =~ /->/) {
      ($before, $after) = split /->/, $newpath;

      if (!create_dir(extractdir($before))) {
	return 0;
      }

      if ($after =~ /\/$/) {
	$after = substr($after,0,length($after)-1);
      }

      if ($after !~ /^\//) {
	$after = $href->{'root'} . "/" . $after;
      }

      if (!symlink($after, $before)) {
	print "Error, could not create symlink($after, $before) in setup for " . $href->{'label'} . "\n";
	return 0;
      }
    } else {
      if ($newpath =~ /\/$/) {
	if (!create_dir($newpath)) {
	  return 0;
	}
      } else {
	if (!create_dir(extractdir($newpath))) {
	  return 0;
	}

	touch($newpath);
      }
    }
  }

  killdir($test_etc);
  create_dir($test_etc);

  if (!open(OUT, ">$test_etc/opt.config")) {
    print "Couldn't open $test_etc/opt.config\n";
    return 0;
  }
  print OUT $href->{'conf'};
  close(OUT);

  if (!open(OUT, ">$test_etc/sites")) {
    print "Couldn't open $test_etc/sites\n";
    return 0;
  }
  print OUT $href->{'sites'};
  close(OUT);

  killdir($test_logdir);
  create_dir($test_logdir);

  if (defined $href->{'priority'}) {
    if (!open(OUT, ">$test_dir/.priority")) {
      print "Couldn't open $test_dir/.priority\n";
      return 0;
    }
    print OUT $href->{'priority'};
    print OUT "\n";
    close(OUT);
  }

  if (defined $href->{'exclude'}) {
    if (!open(OUT, ">$test_dir/.exclude")) {
      print "Couldn't open $test_dir/.exclude\n";
      return 0;
    }
    print OUT $href->{'exclude'};
    print OUT "\n";
    close(OUT);
  }

  return 1;
}

#########################################################################
#
#                                                         exclusion_check
#
# input:
#	a path string
#
#	a reference to a test definition
#
# This method returns 1 if the passed path element is excluded by the
# endex array in the test definition.  This method treats the elements
# in the endex array as regular expressions.
#
#
#########################################################################

sub exclusion_check {
  my ($path, $test_href) = @_;

  my (@ary, $element);

  @ary = @{$test_href->{'endex'}};

  foreach $element (@ary) {
    if ($path =~ /$element/) {
      return 1;
    }
  }

  return 0;
}

#########################################################################
#
#                                                        unexpected_check
#
# input:
#	a path string
#
#	a reference to a test definition
#
#	a reference to a hash mapping directory and path element names
#	to a target (if they should be links) or to empty string if
#	they are physical directories and files.
#
# unexpected_check recurses on the path string, looking at each item found
# and seeing whether it is in the test description's end state.  Any
# path element listed in the test description's endex end state exclusion
# list will not be checked.
#
# returns a count of the number of errors detected during the recursive
# directory check.
#
#########################################################################

sub unexpected_check {
  my ($path, $test_href, $end_href) = @_;

  local(*DIR);
  my($local_path, @elements, $element, $target, $failed, $desired_target, $error_count);

  $error_count = 0;

  chdir($test_href->{'root'});	# make sure we're operating out of the test root

  $local_path = $path;
  if ($local_path eq "") {
    $local_path = ".";
  }

  opendir(DIR, $local_path) || return 0;
  @elements = grep (!/^\.\.?$/, readdir(DIR));
  closedir(DIR);

  # make sure we have base-qualified paths

  if ($path ne "") {
    @elements = map { $path . $_ } @elements;
  }

  foreach $element (@elements) {
    if (-d $element && !-l $element) {
      $element = $element . "/";
    }

    if (exclusion_check($element, $test_href)) {
      next;
    }

    if (-l $element) {
      $target = resolve(make_absolute($local_path), readlink($element));
      $target = resolve($test_href->{'root'} . "/" . $local_path, readlink($element));

      if (!defined $end_href->{$element}) {
	print "Error, found unexpected symlink $element in test " . $test_href->{'label'} . "\n";
	print "Unexpected symlink points to $target\n\n";
	$error_count++;
	next;
      }

      if ($end_href->{$element} eq "") {
	print "Error, found unexpected symlink $element in test " . $test_href->{'label'} . "\n";
	print "Was expecting a file, not a symlink pointing to $target\n\n";
	$error_count++;
	next;
      }

      $desired_target = $test_href->{'root'} . "/" . $end_href->{$element};

      if ($desired_target =~ /\/$/ && $target !~ /\/$/) {
	$target .= "/";
      }

      if ($target ne $desired_target) {
	print "Error, symlink target error in test " . $test_href->{'label'} . "\n";
	print "symlink $element should point to $desired_target, but instead points to\n";
	print "$target.\n\n";

	if (0) {
	  print "\$element is $element\n";
	  print "readlink(\$element) is " . readlink($element) . "\n";
	  print "\$local_path is $local_path\n";
	  print "make_absolute(\$local_path) is " . make_absolute($local_path) . "\n";
	}

	$error_count++;
      }

      next;
    }

    # okay, we've handled the symlink case.. now, is this something we
    # weren't expecting?

    if (!defined $end_href->{$element}) {
      if ($element =~ /\/$/) {
	print "Error, found unexpected directory $element in test " . $test_href->{'label'} . "\n\n";
      } else {
	print "Error, found unexpected item $element in test " . $test_href->{'label'} . "\n\n";
      }

      $error_count++;
      next;
    }

    # now we've got a file or directory where we expected it.. but
    # what if what we were expecting really was a symlink?  That
    # should only happen for files, since if $element is a directory
    # we'll have suffixed a trailing /, and we don't expect to have
    # any symlink definitions look like 'dir/name/->target'..

    if ($end_href->{$element} ne "") {
      $desired_target = $test_href->{'root'} . "/" . $end_href->{$element};

      print "Error, symlink mismatch in test " . $test_href->{'label'} . "\n";
      print "File $element was expected to be a symlink pointing at $desired_target.\n\n";

      $error_count++;
      next;
    }
  }

  # okay, we've finished checking this level.. look to see about recursion

  foreach $element (@elements) {
    if (-d $element && !-l $element) {

      # only recurse if we're not excluding

      if (!exclusion_check($element, $test_href)) {
	$error_count = $error_count + unexpected_check($element, $test_href, $end_href, $exclusion_href);
      }
    }
  }

  return $error_count;
}

#########################################################################
#
#                                                          expected_check
#
# input: a reference to one of our test descriptions
#
# expected_check iterates over the list of expected results for a
# test and makes sure that each expected item affirmatively exists.
#
# this is a complementary function to the unexpected_check, which makes
# sure that we don't have anything we didn't expect
#
# returns a count of the number of errors found
#
#########################################################################

sub expected_check {
  my ($test_href) = @_;

  my ($error_count, @end_ary, $item, $before, $after, $itempath);

  $error_count = 0;

  @end_ary = @{$test_href->{'end'}};

  foreach $item (@end_ary) {
    if ($item =~ /->/) {
      ($before, $after) = split /->/, $item;

      $itempath = $test_href->{'root'} . "/" . $before;
      $desired_target = $test_href->{'root'} . "/" . $after;

	if (!-e $itempath) {
	  print "Error, symlink missing in test " . $test_href->{'label'} . "\n";
	  print "symlink $itempath is supposed to point to $desired_target\n\n";
	  $error_count++;
	  next;
	}
    } else {
      $itempath = $test_href->{'root'} . "/" . $item;

      if ($itempath =~ /\/$/) {
	# directory

	if (!-e $itempath) {
	  print "Error, directory missing in test " . $test_href->{'label'} . "\n";
	  print "$itempath was supposed to be a directory, but does not exist.\n\n";
	  $error_count++;
	  next;
	}
      } else {
	# file

	if (!-e $itempath) {
	  print "Error, file missing in test " . $test_href->{'label'} . "\n";
	  print "file $itempath does not exist.\n\n";
	  $error_count++;
	  next;
	}
      }
    }
  }

  return $error_count;
}

#########################################################################
#
#                                                                run_test
#
# input: a reference to one of our test descriptions
#
# run_test runs the test
#
# returns 1 on success, 0 on failure
#
#########################################################################

sub run_test {
  my ($href) = @_;

  my ($command, @end_ary, $item, $before, $after, %end_hash, $error_count);

  $error_count = 0;

  $command = $href->{'action'};

  if (system($perlloc, "$RealBin/" . $command, "-f$test_etc/opt.config")) {
    print "Could not execute $command with $perlloc.\n";
    return 0;
  };

  # check to make sure we don't have anything in the test tree that we
  # don't expect to be there

  @end_ary = @{$href->{'end'}};

  foreach $item (@end_ary) {
    if ($item =~ /->/) {
      ($before, $after) = split /->/, $item;
      $end_hash{$before} = $after;
    } else {
      $end_hash{$item} = "";
    }
  }

  $error_count = unexpected_check("", $href, \%end_hash);

  # now check to make sure that we affirmatively do have everything in
  # the test tree that we expect

  $error_count = $error_count + expected_check($href);

  if ($error_count != $href->{'error_count'}) {
    if ($error_count > $href->{'error_count'}) {
      print "Test " . $href->{'label'} . " had too many errors.\n";
    } else {
      print "Test " . $href->{'label'} . " had too few errors.\n";
    }

    print "Target errors: " . $href->{'error_count'} . ", Actual errors: $error_count\n";
    return 0;
  } else {
    print "Success\n";
    return 1;
  }
}

#####################################################################
#
# mkdir $test_dir
# mkdir $test_dir/depot
#
# touch a bunch of stuff
# run opt_depot
# test
#####################################################################

$test_failures = 0;
$tests_run = 0;

foreach $test (@tests) {
  print "\n------------------------------------------------------------\n";
  print "Running " . $test->{'action'} . " test '" . $test->{'label'} . "'\n\n";
  setup_test($test);
  if (!run_test($test)) {
    $test_failures++;
  }
  $tests_run++;
}

print "\n------------------------------------------------------------\n";
print "Tests Ran: $tests_run\tTests Succeeded: " . ($tests_run-$test_failures) . "\tTests Failed: " . $test_failures . "\n";

if (!$test_failures) {
  killdir($test_root);
} else {
  print "\n";
  if (!askyn("There were failures encountered.. do you wish to retain the test tree in $test_root?")) {
    killdir($test_root);
  }
}
