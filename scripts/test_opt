#
# test_opt v3.0 -*- Perl -*-
#
# Testing harness for the opt_depot scripts
#
#************************************************************************
#
# Copyright (C) 1993-2003  The University of Texas at Austin.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
#    02111-1307, USA
#
#    Written by: Computer Science Division, Applied Research Laboratories,
#    University of Texas at Austin  opt-depot@arlut.utexas.edu
#
#***********************************************************************
# Written by Jonathan Abbey
# 10 September 2003
#
# Release: $Name:  $
# Version: $Revision: 1.11 $
# Last Mod Date: $Date: 2003/09/16 02:57:57 $
#
#####################################################################

use English;
use FindBin qw($RealBin $RealScript);

use lib "/home/broccol/opt_depot/work/opt_depot/modules";

#use lib "$RealBin/../modules";
use Opt_depot::Common;

$version = "3.0";

## defaults #########################################################

$test_dir = "/tmp/opt_suite/base";
$test_logdir = "/tmp/opt_suite/log";
$test_etc = "/tmp/opt_suite/etc";

#####################################################################

$testconfA =<< "ENDTESTCONF1";
Base: $test_dir
Depot: $test_dir/depot
Log: $test_logdir/opt_depot.log
SiteFile: $test_etc/sites
Subdirs: bin,include,info,lib,man
AlwaysRecurse: No
Recurse: include,lib,info
ENDTESTCONF1

$testsitesA =<< "ENDSITES1";
ENDSITES1

%test0 = (label  => 'Simple single-package link test',
	  root   => $test_dir,
	  start  => ['depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packA/man/manl/test.l'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/', 'man/manl/',
		     'bin/hi->depot/packA/bin/hi',
		     'lib/perl5->depot/packA/lib/perl5/',
		     'include/test.h->depot/packA/include/test.h',
		     'man/manl/test.l->depot/packA/man/manl/test.l'],
	  endex  => ['^depot\/$', '^man\/cat.*\/'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_depot',
	  error_count => 0);

%test1 = (label  => 'Elementary recursion test',
	  root   => $test_dir,
	  start  => ['depot/packA/bin/hi',
		     'depot/packA/lib/perl5/spam/x.pl',
		     'depot/packA/include/test.h',
		     'depot/packB/bin/hi',
		     'depot/packB/lib/perl5/spam/y.pl',
		     'depot/packB/include/test.h'],
	  end    => ['bin/', 'lib/', 'man/', 'include/', 'info/',
		     'bin/hi->depot/packA/bin/hi',
		     'lib/perl5/', 'lib/perl5/spam/',
		     'lib/perl5/spam/x.pl->depot/packA/lib/perl5/spam/x.pl',
		     'lib/perl5/spam/y.pl->depot/packB/lib/perl5/spam/y.pl',
		     'include/test.h->depot/packB/include/test.h'],
	  endex  => ['^depot\/$'],
	  conf   => $testconfA,
	  sites  => $testsitesA,
	  action => 'opt_depot',
	  error_count => 3);

@tests = (\%test0, \%test1);

#####################################################################

#########################################################################
#
#                                                              setup_test
#
# input: a reference to one of our test descriptions
#
# setup_test does everything required to create a test environment for
# a given test, including creating a fresh directory structure.
#
#########################################################################

sub setup_test {
  my ($href) = @_;

  my ($label, $rootdir, $startary, $label, $element, $newpath);

  $label = $href->{'label'};
  $rootdir = $href->{'root'};
  $startary = $href->{'start'};

  print "Setting up \"$label\" at $rootdir\n";

  killdir($rootdir);
  
  foreach $element (@$startary) {

    if ($rootdir =~ /\/$/) {
      $newpath = $rootdir . $element;
    } else {
      $newpath = $rootdir . "/" . $element;
    }

    if ($newpath =~ /\/$/) {
      if (!create_dir($newpath)) {
	return 0;
      }
    } else {
      if (!create_dir(extractdir($newpath))) {
	return 0;
      }

      touch($newpath);
    }
  }

  killdir($test_etc);
  create_dir($test_etc);

  if (!open(OUT, ">$test_etc/opt.config")) {
    print "Couldn't open $test_etc/opt.config";
    return 0;
  }
  print OUT $href->{'conf'};
  close(OUT);

  if (!open(OUT, ">$test_etc/sites")) {
    print "Couldn't open $test_etc/sites";
    return 0;
  }
  print OUT $href->{'sites'};
  close(OUT);

  killdir($test_logdir);
  create_dir($test_logdir);
  
  return 1;
}

#########################################################################
#
#                                                         exclusion_check
#
# input:
#	a path string
#
#	a reference to a test definition
#
# This method returns 1 if the passed path element is excluded by the
# endex array in the test definition.  This method treats the elements
# in the endex array as regular expressions.
#
#
#########################################################################

sub exclusion_check {
  my ($path, $test_href) = @_;
  
  my (@ary, $element);

  @ary = @{$test_href->{'endex'}};

  foreach $element (@ary) {
    if ($path =~ /$element/) {
      return 1;
    }
  }

  return 0;
}

#########################################################################
#
#                                                           recurse_check
#
# input:
#	a path string
#
#	a reference to a test definition
#
#	a reference to a hash mapping directory and path element names
#	to a target (if they should be links) or to empty string if
#	they are physical directories and files.
#
#
# recurse_check recurses on the path string, looking at each item found
# and seeing whether it is in the test description's end state.  Any
# path element listed in the test description's endex end state exclusion
# list will not be checked.
#
# returns 1 on success, 0 on failure
#
#########################################################################

sub recurse_check {
  my ($path, $test_href, $end_href) = @_;

  local(*DIR);
  my($local_path, @elements, $element, $target, $failed, $desired_target, $error_count);

  $error_count = 0;

  chdir($test_href->{'root'});	# make sure we're operating out of the test root

  $local_path = $path;
  if ($local_path eq "") {
    $local_path = ".";
  }

  opendir(DIR, $local_path) || return 0;
  @elements = grep (!/^\.\.?$/, readdir(DIR));
  closedir(DIR);

  # make sure we have base-qualified paths

  if ($path ne "") {
    @elements = map { $path . $_ } @elements;
  }
  
  foreach $element (@elements) {
    if (-d $element && !-l $element) {
      $element = $element . "/";
    }

    if (exclusion_check($element, $test_href)) {
      next;
    }

    if (-l $element) {
      $target = resolve(make_absolute($local_path), readlink($element));

      $desired_target = $test_href->{'root'} . "/" . $end_href->{$element};

      if ($desired_target =~ /\/$/ && $target !~ /\/$/) {
	$target .= "/";
      }

      if ($target ne $desired_target) {
	print "Error, symlink target error in test " . $test_href->{'label'} . "\n";
	print "symlink $element should point to $desired_target, but instead points to\n";
	print "$target.\n";
	$error_count++;
	next;
      }
    } elsif (!defined $end_href->{$element}) {
      print "Error, found unexpected item $element in test " . $test_href->{'label'} . "\n";
      $error_count++;
      next;
    }
  }

  # okay, we've finished checking this level.. look to see about recursion

  foreach $element (@elements) {
    if (-d $element && !-l $element) {
      
      # only recurse if we're not excluding

      if (!exclusion_check($element, $test_href)) {
	$error_count = $error_count + recurse_check($element, $test_href, $end_href, $exclusion_href);
      }
    }
  }

  return $error_count;
}

#########################################################################
#
#                                                                run_test
#
# input: a reference to one of our test descriptions
#
# run_test runs the test
#
# returns 1 on success, 0 on failure
#
#########################################################################

sub run_test {
  my ($href) = @_;

  my ($command, @end_ary, $item, $before, $after, %end_hash);

  $command = $href->{'action'};

  if (system('/opt/bin/perl', "$RealBin/" . $command, "-f$test_etc/opt.config")) {
    print "Could not execute $command with perl.\n";
    return 0;
  };

  # start the recurse_check from our base directory

  @end_ary = @{$href->{'end'}};
  
  foreach $item (@end_ary) {
    if ($item =~ /->/) {
      ($before, $after) = split /->/, $item;
      $end_hash{$before} = $after;
    } else {
      $end_hash{$item} = "";
    }
  }

  $result = recurse_check("", $href, \%end_hash);

  if ($result != $href->{'error_count'}) {
    if ($result > $href->{'error_count'}) {
      print "\nTest " . $href->{'label'} . " had too many errors.\n";
    } else {
      print "\nTest " . $href->{'label'} . " had too few errors.\n";
    }

    print "Target errors: " . $href->{'error_count'} . ", Actual errors: $result\n";
    return 0;
  } else {
    print "\nTest " . $href->{'label'} . " had the expected number of errors.\n";
    return 1;
  }
}

#####################################################################
#
# mkdir $test_dir
# mkdir $test_dir/depot
#
# touch a bunch of stuff
# run opt_depot
# test
#####################################################################

$test_failures = 0;
$tests_run = 0;

foreach $test (@tests) {
  print "\n------------------------------------------------------------\n";
  print "Running test " . $test->{'label'} . "\n\n";
  setup_test($test);
  if (!run_test($test)) {
    $test_failures++;
  }
  $tests_run++;
}

print "\n------------------------------------------------------------\n";
print "Tests Ran: $tests_run\tTests Succeeded: " . ($tests_run-$test_failures) . "\tTests Failed: " . $test_failures . "\n";
